<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SRTM Terrain Profile</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #0a0c0f;
    --bg-panel: #111418;
    --bg-input: #161a22;
    --border: #2a3040;
    --border-focus: #4e9fff;
    --text: #c8d0dc;
    --text-dim: #606878;
    --accent: #4e9fff;
    --accent-warm: #ffb340;
    --accent-green: #4effa0;
    --danger: #ff5c5c;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'IBM Plex Mono', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* ─── Header ─── */
  header {
    border-bottom: 1px solid var(--border);
    padding: 28px 40px 24px;
    background: var(--bg-panel);
    position: relative;
  }
  header::after {
    content: '';
    position: absolute;
    bottom: -1px; left: 0; right: 0; height: 2px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.4;
  }
  .header-inner { max-width: 1100px; margin: 0 auto; display: flex; align-items: flex-end; gap: 24px; }
  h1 { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 1.6rem; letter-spacing: -0.02em; color: #fff; line-height: 1.1; }
  h1 span { color: var(--accent); }
  .header-sub { font-size: 0.72rem; color: var(--text-dim); letter-spacing: 0.08em; text-transform: uppercase; margin-left: auto; }

  /* ─── Layout ─── */
  .container { max-width: 1100px; margin: 0 auto; padding: 28px 40px 60px; }

  /* ─── Panels ─── */
  .panel {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 22px 24px;
    margin-bottom: 20px;
  }
  .panel-label {
    font-size: 0.68rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .panel-label::before {
    content: '';
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 6px var(--accent);
  }

  /* ─── Mode toggle ─── */
  .mode-toggle {
    display: flex;
    gap: 4px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px;
    width: fit-content;
    margin-bottom: 18px;
  }
  .mode-btn {
    font-family: inherit;
    font-size: 0.74rem;
    letter-spacing: 0.06em;
    padding: 7px 18px;
    border: none;
    border-radius: 6px;
    background: transparent;
    color: var(--text-dim);
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
  }
  .mode-btn:hover { color: var(--text); }
  .mode-btn.active {
    background: var(--accent);
    color: #0a0c0f;
    font-weight: 500;
  }

  /* ─── Drop zone ─── */
  .dropzone {
    border: 2px dashed var(--border);
    border-radius: 8px;
    padding: 32px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    background: var(--bg-input);
  }
  .dropzone:hover, .dropzone.dragover { border-color: var(--accent); background: rgba(78,159,255,0.04); }
  .dropzone input { display: none; }
  .dropzone .dz-icon { font-size: 1.8rem; margin-bottom: 8px; opacity: 0.5; }
  .dropzone .dz-text { font-size: 0.78rem; color: var(--text-dim); }
  .dropzone .dz-text em { color: var(--accent); font-style: normal; }

  /* ─── Tile tags ─── */
  .tile-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 14px; }
  .tile-tag {
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 5px 10px;
    font-size: 0.73rem;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .tile-tag .tag-name { color: var(--accent-warm); font-weight: 500; }
  .tile-tag .tag-res { color: var(--text-dim); font-size: 0.65rem; }
  .tile-tag .tag-remove { cursor: pointer; color: var(--text-dim); font-size: 0.9rem; line-height: 1; transition: color 0.15s; }
  .tile-tag .tag-remove:hover { color: var(--danger); }

  /* ─── Mode sections ─── */
  .mode-section { display: none; }
  .mode-section.active { display: block; }

  /* ─── Coordinates ─── */
  .coord-row { display: grid; grid-template-columns: 1fr 40px 1fr; gap: 12px; align-items: end; }
  .coord-block .coord-label { font-size: 0.68rem; color: var(--text-dim); letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 6px; }
  .coord-fields { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .input-wrap label { display: block; font-size: 0.62rem; color: var(--text-dim); margin-bottom: 3px; letter-spacing: 0.06em; }
  .input-wrap input, .input-wrap select {
    width: 100%;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: #fff;
    font-family: inherit;
    font-size: 0.82rem;
    padding: 8px 10px;
    transition: border-color 0.2s;
    outline: none;
  }
  .input-wrap input:focus, .input-wrap select:focus { border-color: var(--border-focus); }

  .arrow-col { display: flex; align-items: center; justify-content: center; padding-bottom: 12px; }
  .arrow-col span { color: var(--accent); font-size: 1.3rem; opacity: 0.7; }

  /* ─── Radial inputs ─── */
  .radial-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }

  /* ─── Action row ─── */
  .action-row { display: flex; align-items: center; gap: 14px; flex-wrap: wrap; }
  .btn {
    font-family: inherit;
    font-size: 0.76rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 10px 22px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s, box-shadow 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .btn:active { transform: scale(0.96); }
  .btn-primary { background: var(--accent); color: #0a0c0f; font-weight: 500; box-shadow: 0 2px 12px rgba(78,159,255,0.25); }
  .btn-primary:hover { background: #6aadff; box-shadow: 0 2px 18px rgba(78,159,255,0.35); }
  .btn-primary:disabled { background: #2a3a50; color: var(--text-dim); box-shadow: none; cursor: not-allowed; }
  .btn-secondary { background: transparent; color: var(--text-dim); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); color: var(--text); }

  .status-msg { font-size: 0.72rem; color: var(--text-dim); flex: 1; }
  .status-msg.err { color: var(--danger); }
  .status-msg.ok { color: var(--accent-green); }

  .samples-wrap { display: flex; align-items: center; gap: 10px; }
  .samples-wrap label { font-size: 0.68rem; color: var(--text-dim); letter-spacing: 0.06em; }
  .samples-wrap select {
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text);
    font-family: inherit;
    font-size: 0.75rem;
    padding: 5px 8px;
    outline: none;
  }

  /* ─── Output panels ─── */
  .output-panel { display: none; }
  .output-panel.visible { display: block; }

  .profile-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 8px; }
  .profile-stats { display: flex; gap: 24px; flex-wrap: wrap; }
  .stat { display: flex; flex-direction: column; }
  .stat-label { font-size: 0.6rem; color: var(--text-dim); letter-spacing: 0.1em; text-transform: uppercase; }
  .stat-value { font-size: 0.88rem; color: #fff; font-weight: 500; margin-top: 2px; }
  .stat-value .unit { color: var(--text-dim); font-size: 0.68rem; margin-left: 3px; }

  canvas {
    display: block;
    border-radius: 6px;
    background: var(--bg);
    border: 1px solid var(--border);
    cursor: crosshair;
  }
  #profileCanvas { width: 100%; }

  .canvas-wrap { position: relative; }
  .tooltip {
    position: absolute;
    background: rgba(17,20,24,0.92);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 7px 11px;
    font-size: 0.7rem;
    color: var(--text);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    white-space: nowrap;
    z-index: 10;
  }
  .tooltip.visible { opacity: 1; }
  .tooltip .tt-elev { color: var(--accent); font-weight: 500; }
  .tooltip .tt-dist { color: var(--text-dim); }

  .export-row { margin-top: 14px; display: flex; gap: 10px; }

  /* ─── Terrain map ─── */
  #terrainMapCanvas, #radialTerrainMapCanvas { width: 100%; height: 400px; cursor: grab; }
  #terrainMapCanvas.panning, #radialTerrainMapCanvas.panning { cursor: grabbing; }
  .map-info { font-size: 0.7rem; color: var(--text-dim); margin-top: 10px; }
  .map-hover-info {
    position: absolute;
    background: rgba(17,20,24,0.95);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 0.7rem;
    color: var(--text);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    z-index: 10;
    min-width: 140px;
  }
  .map-hover-info.visible { opacity: 1; }
  .map-hover-info.frozen { border-color: var(--accent); }
  .map-hover-info div { margin: 2px 0; }
  .map-hover-info .info-label { color: var(--text-dim); display: inline-block; width: 50px; }
  .map-hover-info .info-value { color: var(--accent); font-weight: 500; }
  .map-controls {
    display: flex;
    gap: 8px;
    margin-top: 10px;
  }
  .map-controls button {
    font-size: 0.7rem;
    padding: 5px 10px;
  }
  .minimap {
    position: absolute;
    bottom: 10px;
    right: 10px;
    width: 120px;
    height: 80px;
    border: 2px solid var(--border);
    border-radius: 4px;
    background: rgba(10,12,15,0.9);
    cursor: pointer;
    z-index: 5;
  }
  .zoom-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(17,20,24,0.9);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 0.7rem;
    color: var(--accent);
    font-weight: 500;
    z-index: 5;
  }

  /* ─── Profile options ─── */
  .profile-options { 
    display: flex; 
    gap: 14px; 
    flex-wrap: wrap; 
    margin-bottom: 16px;
    padding: 12px;
    background: var(--bg-input);
    border-radius: 6px;
    border: 1px solid var(--border);
  }
  .option-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .option-group label {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
  }
  .option-group input[type="number"] {
    width: 80px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: #fff;
    font-family: inherit;
    font-size: 0.76rem;
    padding: 5px 8px;
  }
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .checkbox-group input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .checkbox-group label {
    font-size: 0.72rem;
    color: var(--text);
    cursor: pointer;
  }

  /* ─── Radial layout ─── */
  .radial-output-layout {
    display: grid;
    grid-template-columns: 420px 1fr;
    gap: 20px;
    align-items: start;
  }
  @media (max-width: 780px) {
    .radial-output-layout { grid-template-columns: 1fr; }
  }
  .radial-polar-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #radialCanvas { width: 400px; height: 400px; }
  .radial-legend {
    display: flex;
    gap: 18px;
    margin-top: 12px;
    font-size: 0.7rem;
    color: var(--text-dim);
  }
  .radial-legend .leg-swatch {
    width: 12px; height: 12px;
    border-radius: 3px;
    display: inline-block;
    margin-right: 5px;
    vertical-align: middle;
  }

  .radial-table-wrap { overflow-x: auto; }
  .radial-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.72rem;
  }
  .radial-table th {
    text-align: left;
    color: var(--text-dim);
    font-weight: 400;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-size: 0.62rem;
    border-bottom: 1px solid var(--border);
    padding: 6px 8px;
  }
  .radial-table td {
    padding: 5px 8px;
    border-bottom: 1px solid rgba(42,48,64,0.5);
    color: var(--text);
  }
  .radial-table tr:hover td { background: rgba(78,159,255,0.04); }
  .radial-table .vis { color: var(--accent-green); font-weight: 500; }
  .radial-table .blk { color: var(--danger); }

  /* scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<header>
  <div class="header-inner">
    <div><h1>SRTM <span>Terrain Profile</span></h1></div>
    <div class="header-sub">elevation · line of sight</div>
  </div>
</header>

<div class="container">

  <!-- 1. Load tiles -->
  <div class="panel">
    <div class="panel-label">1 — Load HGT Tiles</div>
    <div class="dropzone" id="dropzone">
      <input type="file" id="fileInput" accept=".hgt" multiple />
      <div class="dz-icon">⬇</div>
      <div class="dz-text">Drop <em>.hgt</em> files here or <em>click to browse</em></div>
    </div>
    <div class="tile-list" id="tileList"></div>
  </div>

  <!-- 1b. Terrain Map -->
  <div class="panel output-panel" id="terrainMapPanel">
    <div class="panel-label">Terrain Map</div>
    <div class="canvas-wrap">
      <canvas id="terrainMapCanvas"></canvas>
      <canvas class="minimap" id="minimapCanvas"></canvas>
      <div class="zoom-indicator" id="zoomIndicator">1.0x</div>
      <div class="map-hover-info" id="mapHoverInfo">
        <div><span class="info-label">Lat:</span><span class="info-value" id="hoverLat">—</span></div>
        <div><span class="info-label">Lng:</span><span class="info-value" id="hoverLng">—</span></div>
        <div><span class="info-label">Elev:</span><span class="info-value" id="hoverElev">—</span></div>
      </div>
    </div>
    <div class="map-controls">
      <button class="btn btn-secondary" id="btnResetZoom">Reset Zoom</button>
      <button class="btn btn-secondary" id="btnSaveTiles">Save Tiles</button>
      <button class="btn btn-secondary" id="btnLoadTiles">Load Saved Tiles</button>
    </div>
    <div class="map-info" id="mapInfo"></div>
  </div>

  <!-- 2. Mode + inputs -->
  <div class="panel">
    <div class="panel-label">2 — Configure</div>

    <!-- mode toggle -->
    <div class="mode-toggle">
      <button class="mode-btn active" data-mode="ab">A → B Profile</button>
      <button class="mode-btn" data-mode="radial">Radial Line-of-Sight</button>
    </div>

    <!-- A→B inputs -->
    <div class="mode-section active" id="section-ab">
      <div class="coord-row">
        <div class="coord-block">
          <div class="coord-label">▸ Start</div>
          <div class="coord-fields">
            <div class="input-wrap"><label>Latitude</label><input type="text" id="startLat" placeholder="e.g. 48.8566" /></div>
            <div class="input-wrap"><label>Longitude</label><input type="text" id="startLng" placeholder="e.g. 2.3522" /></div>
          </div>
        </div>
        <div class="arrow-col"><span>→</span></div>
        <div class="coord-block">
          <div class="coord-label">▸ End</div>
          <div class="coord-fields">
            <div class="input-wrap"><label>Latitude</label><input type="text" id="endLat" placeholder="e.g. 48.9566" /></div>
            <div class="input-wrap"><label>Longitude</label><input type="text" id="endLng" placeholder="e.g. 2.4522" /></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Radial inputs -->
    <div class="mode-section" id="section-radial">
      <div class="radial-row">
        <div class="input-wrap"><label>Latitude</label><input type="text" id="radLat" placeholder="e.g. 48.8566" /></div>
        <div class="input-wrap"><label>Longitude</label><input type="text" id="radLng" placeholder="e.g. 2.3522" /></div>
        <div class="input-wrap"><label>Radius (km)</label><input type="text" id="radRadius" placeholder="e.g. 10" /></div>
      </div>
      <div style="display:flex; gap:16px; margin-top:14px; flex-wrap:wrap;">
        <div class="input-wrap" style="width:160px;">
          <label>Angular resolution (°)</label>
          <select id="radAngRes">
            <option value="0.5">0.5°  (720 rays)</option>
            <option value="1" selected>1°   (360 rays)</option>
            <option value="2">2°   (180 rays)</option>
            <option value="5">5°   (72 rays)</option>
          </select>
        </div>
        <div class="input-wrap" style="width:160px;">
          <label>Samples per ray</label>
          <select id="radSamples">
            <option value="200">200</option>
            <option value="500" selected>500</option>
            <option value="1000">1 000</option>
          </select>
        </div>
        <div class="input-wrap" style="width:160px;">
          <label>Local observer height (m)</label>
          <input type="text" id="radObsHeight" value="0" />
        </div>
        <div class="input-wrap" style="width:180px;">
          <label>Max remote tower height (m)</label>
          <input type="number" id="radMaxTowerHeight" value="50" min="0" step="5" />
        </div>
      </div>
      <div style="margin-top:14px; display:flex; gap:16px; flex-wrap:wrap;">
        <div class="checkbox-group">
          <input type="checkbox" id="showRadialHeatmap" />
          <label for="showRadialHeatmap">Show tower height heatmap</label>
        </div>
        <div class="checkbox-group">
          <input type="checkbox" id="showRadialTerrain" />
          <label for="showRadialTerrain">Overlay terrain on polar plot</label>
        </div>
      </div>
    </div>
  </div>

  <!-- 3. Generate -->
  <div class="panel">
    <div class="panel-label">3 — Generate</div>
    <div class="action-row">
      <button class="btn btn-primary" id="btnGenerate" disabled>Generate</button>
      <button class="btn btn-secondary" id="btnClear">Clear All</button>
      <div class="samples-wrap" id="abSamplesWrap">
        <label>Samples</label>
        <select id="sampleCount">
          <option value="500">500</option>
          <option value="1000" selected>1 000</option>
          <option value="2000">2 000</option>
          <option value="5000">5 000</option>
        </select>
      </div>
      <div class="status-msg" id="statusMsg"></div>
    </div>
  </div>

  <!-- 4a. A→B Profile output -->
  <div class="panel output-panel" id="profilePanel">
    <div class="panel-label">4 — Elevation Profile</div>
    <div class="profile-header-row">
      <div class="profile-stats">
        <div class="stat"><span class="stat-label">Distance</span><span class="stat-value" id="statDist">—</span></div>
        <div class="stat"><span class="stat-label">Max Elev</span><span class="stat-value" id="statMax">—</span></div>
        <div class="stat"><span class="stat-label">Min Elev</span><span class="stat-value" id="statMin">—</span></div>
        <div class="stat"><span class="stat-label">Start Elev</span><span class="stat-value" id="statStart">—</span></div>
        <div class="stat"><span class="stat-label">End Elev</span><span class="stat-value" id="statEnd">—</span></div>
        <div class="stat"><span class="stat-label">LOS</span><span class="stat-value" id="statLOS">—</span></div>
      </div>
    </div>
    <div class="profile-options">
      <div class="option-group">
        <label>Start tower (m)</label>
        <input type="number" id="startTowerHeight" value="10" min="0" step="1" />
      </div>
      <div class="option-group">
        <label>End tower (m)</label>
        <input type="number" id="endTowerHeight" value="10" min="0" step="1" />
      </div>
      <div class="option-group">
        <label>Tree height (m)</label>
        <input type="number" id="treeHeight" value="5" min="0" step="0.5" />
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showLOS" checked />
        <label for="showLOS">Line of sight</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showUserTowers" checked />
        <label for="showUserTowers">User towers</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showMinTowers" />
        <label for="showMinTowers">Min tower heights</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showOptimalTowers" />
        <label for="showOptimalTowers">Optimal combined towers</label>
      </div>
      <button class="btn btn-secondary" id="btnUpdateProfile" style="margin-left:auto;">Update</button>
    </div>
    <div class="canvas-wrap">
      <canvas id="profileCanvas" height="320"></canvas>
      <div class="tooltip" id="tooltip">
        <span class="tt-elev" id="ttElev">0 m</span>
        <span class="tt-dist" id="ttDist"> · 0 km</span>
      </div>
    </div>
    <div class="export-row">
      <button class="btn btn-secondary" id="btnExportCSV">⬇ Export CSV</button>
      <button class="btn btn-secondary" id="btnExportPNG">⬇ Export PNG</button>
    </div>
  </div>

  <!-- 4b. Radial output -->
  <div class="panel output-panel" id="radialPanel">
    <div class="panel-label">4 — Radial Line-of-Sight</div>
    <div class="profile-header-row">
      <div class="profile-stats">
        <div class="stat"><span class="stat-label">Radius</span><span class="stat-value" id="rStatRadius">—</span></div>
        <div class="stat"><span class="stat-label">Rays cast</span><span class="stat-value" id="rStatRays">—</span></div>
        <div class="stat"><span class="stat-label">Visible</span><span class="stat-value" id="rStatVis">—</span></div>
        <div class="stat"><span class="stat-label">Blocked</span><span class="stat-value" id="rStatBlk">—</span></div>
        <div class="stat"><span class="stat-label">Obs. Elev</span><span class="stat-value" id="rStatObsElev">—</span></div>
      </div>
    </div>
    <div class="canvas-wrap" style="margin-bottom: 20px;">
      <canvas id="radialTerrainMapCanvas" width="600" height="400"></canvas>
      <div class="map-hover-info" id="radMapHoverInfo">
        <div><span class="info-label">Lat:</span><span class="info-value" id="radHoverLat">—</span></div>
        <div><span class="info-label">Lng:</span><span class="info-value" id="radHoverLng">—</span></div>
        <div><span class="info-label">Elev:</span><span class="info-value" id="radHoverElev">—</span></div>
      </div>
    </div>
    <div class="radial-output-layout">
      <div class="radial-polar-wrap" style="display:none;">
        <div class="canvas-wrap">
          <canvas id="radialCanvas" width="400" height="400"></canvas>
          <div class="tooltip" id="radTooltip">
            <span class="tt-elev" id="rttBearing">0°</span>
            <span class="tt-dist" id="rttDist"> · 0 km</span>
          </div>
        </div>
        <div class="radial-legend">
          <span><span class="leg-swatch" style="background:#4effa0;"></span>Visible</span>
          <span><span class="leg-swatch" style="background:#ff5c5c;"></span>Blocked</span>
          <span><span class="leg-swatch" style="background:#ffb340;"></span>Observer</span>
        </div>
      </div>
      <div class="radial-table-wrap" style="display:none;">
        <table class="radial-table" id="radialTable">
          <thead><tr><th>Bearing</th><th>Status</th><th>Visible dist</th><th>Block elev</th></tr></thead>
          <tbody id="radialTableBody"></tbody>
        </table>
      </div>
    </div>
    <div class="export-row">
      <button class="btn btn-secondary" id="btnExportRadialPNG">⬇ Export PNG</button>
      <button class="btn btn-secondary" id="btnExportRadialCSV">⬇ Export CSV</button>
    </div>
  </div>

</div>

<script>
// Wrap everything in DOMContentLoaded to ensure DOM is ready
document.addEventListener('DOMContentLoaded', function() {

/* ═══════════════════════════════════════════════════════════
   STATE
   ═══════════════════════════════════════════════════════════ */
const tiles = {};
let profileData  = [];    // A→B: [{dist, elev}]
let radialData   = [];    // radial: [{bearing, visible, visibleDist, blockElev, blockDist}]
let currentMode  = 'ab';  // 'ab' | 'radial'
let cachedLOS    = null;  // last LOS result for resize redraws
let filesLoading = 0;     // track number of files being loaded

/* ═══════════════════════════════════════════════════════════
   INDEXEDDB HELPERS (for large HGT files)
   ═══════════════════════════════════════════════════════════ */
let db = null;

function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('SRTMDatabase', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('tiles')) {
        db.createObjectStore('tiles', { keyPath: 'key' });
      }
    };
  });
}

function saveTilesToStorage() {
  if (!db) {
    console.error('Database not initialized');
    return;
  }
  
  try {
    console.log('Saving tiles:', Object.keys(tiles));
    const transaction = db.transaction(['tiles'], 'readwrite');
    const store = transaction.objectStore('tiles');
    
    // Clear existing tiles first
    store.clear();
    
    // Save each tile
    Object.keys(tiles).forEach(key => {
      store.put({
        key: key,
        data: Array.from(tiles[key].data),
        size: tiles[key].size
      });
    });
    
    transaction.oncomplete = () => {
      setStatus(`Saved ${Object.keys(tiles).length} tiles to browser storage`, false);
      console.log('All tiles saved successfully');
    };
    
    transaction.onerror = () => {
      setStatus('Error saving tiles: ' + transaction.error, true);
      console.error('Save error:', transaction.error);
    };
  } catch (e) {
    console.error('Save error:', e);
    setStatus('Error saving tiles: ' + e.message, true);
  }
}

function loadTilesFromStorage() {
  if (!db) {
    console.error('Database not initialized');
    return;
  }
  
  try {
    const transaction = db.transaction(['tiles'], 'readonly');
    const store = transaction.objectStore('tiles');
    const request = store.getAll();
    
    request.onsuccess = () => {
      const savedTiles = request.result;
      if (savedTiles.length === 0) {
        setStatus('No saved tiles found', false);
        return;
      }
      
      Object.keys(tiles).forEach(k => delete tiles[k]);
      savedTiles.forEach(tile => {
        tiles[tile.key] = {
          data: new Int16Array(tile.data),
          size: tile.size
        };
      });
      
      renderTileTags();
      updateBtn();
      
      // Reset zoom to fit all loaded tiles
      mapZoom = 1;
      mapOffsetX = 0;
      mapOffsetY = 0;
      
      // Ensure terrain map panel is visible first, then draw after layout settles
      terrainMapPanel.classList.add('visible');
      setTimeout(() => {
        drawTerrainMap();
      }, 50);
      
      setStatus(`Loaded ${Object.keys(tiles).length} tiles from browser storage`, false);
      console.log('Loaded tiles:', Object.keys(tiles));
    };
    
    request.onerror = () => {
      setStatus('Error loading tiles: ' + request.error, true);
      console.error('Load error:', request.error);
    };
  } catch (e) {
    console.error('Load error:', e);
    setStatus('Error loading tiles: ' + e.message, true);
  }
}

function saveInputsToStorage() {
  const inputs = {
    startLat: document.getElementById('startLat').value,
    startLng: document.getElementById('startLng').value,
    endLat: document.getElementById('endLat').value,
    endLng: document.getElementById('endLng').value,
    radLat: document.getElementById('radLat').value,
    radLng: document.getElementById('radLng').value,
    radRadius: document.getElementById('radRadius').value,
    startTowerHeight: document.getElementById('startTowerHeight')?.value || '10',
    endTowerHeight: document.getElementById('endTowerHeight')?.value || '10',
    treeHeight: document.getElementById('treeHeight')?.value || '5',
    radObsHeight: document.getElementById('radObsHeight').value,
    radMaxTowerHeight: document.getElementById('radMaxTowerHeight')?.value || '50'
  };
  localStorage.setItem('srtm_inputs', JSON.stringify(inputs));
}

function loadInputsFromStorage() {
  try {
    const stored = localStorage.getItem('srtm_inputs');
    if (!stored) return;
    const inputs = JSON.parse(stored);
    Object.keys(inputs).forEach(key => {
      const el = document.getElementById(key);
      if (el && inputs[key]) el.value = inputs[key];
    });
  } catch (e) {
    console.error('Error loading inputs:', e);
  }
}

/* ═══════════════════════════════════════════════════════════
   DOM REFS
   ═══════════════════════════════════════════════════════════ */
const dropzone     = document.getElementById('dropzone');
const fileInput    = document.getElementById('fileInput');
const tileList     = document.getElementById('tileList');
const btnGen       = document.getElementById('btnGenerate');
const btnClear     = document.getElementById('btnClear');
const statusMsg    = document.getElementById('statusMsg');

const terrainMapPanel = document.getElementById('terrainMapPanel');
const mapCanvas    = document.getElementById('terrainMapCanvas');
const mctx         = mapCanvas.getContext('2d');
const mapHoverInfo = document.getElementById('mapHoverInfo');
const minimapCanvas = document.getElementById('minimapCanvas');
const mmctx        = minimapCanvas.getContext('2d');
const radMapCanvas = document.getElementById('radialTerrainMapCanvas');
const radMctx      = radMapCanvas ? radMapCanvas.getContext('2d') : null;
const radMapHoverInfo = document.getElementById('radMapHoverInfo');

// Terrain map state
let mapZoom = 1;
let mapOffsetX = 0;
let mapOffsetY = 0;
let mapIsPanning = false;
let mapLastX = 0;
let mapLastY = 0;
let mapHoverFrozen = false;
let radMapHoverFrozen = false;
let lastRadialParams = null; // Store last radial generation params

const profilePanel = document.getElementById('profilePanel');
const canvas       = document.getElementById('profileCanvas');
const ctx          = canvas.getContext('2d');
const tooltip      = document.getElementById('tooltip');

const radialPanel  = document.getElementById('radialPanel');
const radCanvas    = document.getElementById('radialCanvas');
const rctx         = radCanvas.getContext('2d');
const radTooltip   = document.getElementById('radTooltip');

const abSamplesWrap= document.getElementById('abSamplesWrap');

/* ═══════════════════════════════════════════════════════════
   INITIALIZATION
   ═══════════════════════════════════════════════════════════ */
// Load inputs first
loadInputsFromStorage();

// Auto-save inputs on change
['startLat','startLng','endLat','endLng','radLat','radLng','radRadius','startTowerHeight','endTowerHeight','treeHeight','radObsHeight','radMaxTowerHeight'].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('change', saveInputsToStorage);
});

/* ═══════════════════════════════════════════════════════════
   MODE TOGGLE
   ═══════════════════════════════════════════════════════════ */
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    currentMode = btn.dataset.mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b === btn));
    document.getElementById('section-ab').classList.toggle('active', currentMode === 'ab');
    document.getElementById('section-radial').classList.toggle('active', currentMode === 'radial');
    abSamplesWrap.style.display = currentMode === 'ab' ? 'flex' : 'none';
    // hide outputs when switching
    profilePanel.classList.remove('visible');
    radialPanel.classList.remove('visible');
  });
});

/* ═══════════════════════════════════════════════════════════
   DROPZONE / FILE LOADING
   ═══════════════════════════════════════════════════════════ */
dropzone.addEventListener('click', () => fileInput.click());
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', e => { e.preventDefault(); dropzone.classList.remove('dragover'); });
dropzone.addEventListener('drop', e => { e.preventDefault(); dropzone.classList.remove('dragover'); loadFiles(e.dataTransfer.files); });
fileInput.addEventListener('change', e => loadFiles(e.target.files));

function loadFiles(files) {
  const fileArray = [...files].filter(f => f.name.toLowerCase().endsWith('.hgt'));
  if (fileArray.length === 0) return;
  
  filesLoading = fileArray.length; // Track how many files we're loading
  
  fileArray.forEach(file => {
    const reader = new FileReader();
    reader.onload = ev => {
      const buf   = ev.target.result;
      const count = buf.byteLength / 2;
      let size;
      if      (count === 1201 * 1201) size = 1201;
      else if (count === 3601 * 3601) size = 3601;
      else { 
        setStatus(`${file.name}: unrecognised size (${count} samples)`, true); 
        filesLoading--;
        if (filesLoading === 0) saveTilesToStorage();
        return; 
      }

      const view = new DataView(buf);
      const arr  = new Int16Array(count);
      for (let i = 0; i < count; i++) arr[i] = view.getInt16(i * 2, false);

      const key = parseTileKey(file.name);
      if (!key) { 
        setStatus(`${file.name}: bad filename`, true); 
        filesLoading--;
        if (filesLoading === 0) saveTilesToStorage();
        return; 
      }
      
      tiles[key] = { data: arr, size };
      console.log('Tile added:', key, 'Total tiles:', Object.keys(tiles).length); // Debug
      renderTileTags();
      updateBtn();
      drawTerrainMap();
      setStatus(`Loaded ${file.name} (${size === 1201 ? '3″' : '1″'} · ${key})`, false);
      
      // Decrement counter and save when all files are loaded
      filesLoading--;
      console.log('Files remaining:', filesLoading); // Debug
      if (filesLoading === 0) {
        console.log('All files loaded, saving...'); // Debug
        saveTilesToStorage();
        setStatus(`All tiles loaded and saved (${Object.keys(tiles).length} total)`, false);
      }
    };
    reader.readAsArrayBuffer(file);
  });
  fileInput.value = '';
}

function parseTileKey(name) {
  const m = name.match(/^([NS])(\d+)([EW])(\d+)\.hgt$/i);
  if (!m) return null;
  const lat = parseInt(m[2]) * (m[1].toUpperCase() === 'N' ? 1 : -1);
  const lng = parseInt(m[4]) * (m[3].toUpperCase() === 'E' ? 1 : -1);
  return tileKeyFromCoord(lat, lng);
}

function tileKeyFromCoord(latBase, lngBase) {
  const ns = latBase >= 0 ? 'N' : 'S';
  const ew = lngBase >= 0 ? 'E' : 'W';
  return `${ns}${String(Math.abs(latBase)).padStart(2,'0')}${ew}${String(Math.abs(lngBase)).padStart(3,'0')}`;
}

function drawTerrainMap(canvas = mapCanvas, ctx = mctx, centerLat = null, centerLng = null, radiusKm = null) {
  const tileKeys = Object.keys(tiles);
  if (tileKeys.length === 0) {
    terrainMapPanel.classList.remove('visible');
    return;
  }

  // Calculate bounds of all loaded tiles
  let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
  
  if (centerLat !== null && centerLng !== null && radiusKm !== null) {
    // For radial view: show area around center point
    const latPerKm = 1 / 111.32; // approximate
    const lngPerKm = 1 / (111.32 * Math.cos(centerLat * DEG2RAD));
    const margin = 1.2; // 20% margin
    minLat = centerLat - radiusKm * latPerKm * margin;
    maxLat = centerLat + radiusKm * latPerKm * margin;
    minLng = centerLng - radiusKm * lngPerKm * margin;
    maxLng = centerLng + radiusKm * lngPerKm * margin;
  } else {
    // For main map: show all tiles
    tileKeys.forEach(key => {
      const m = key.match(/^([NS])(\d+)([EW])(\d+)$/);
      if (!m) return;
      const lat = parseInt(m[2]) * (m[1] === 'N' ? 1 : -1);
      const lng = parseInt(m[4]) * (m[3] === 'E' ? 1 : -1);
      minLat = Math.min(minLat, lat);
      maxLat = Math.max(maxLat, lat + 1);
      minLng = Math.min(minLng, lng);
      maxLng = Math.max(maxLng, lng + 1);
    });
  }

  const latRange = maxLat - minLat;
  const lngRange = maxLng - minLng;
  
  const dpr = window.devicePixelRatio || 1;
  // Make canvas fill its container while maintaining aspect ratio
  const rect = canvas.parentElement.getBoundingClientRect();
  const containerW = Math.max(Math.floor(rect.width), 600);
  const containerH = 400;
  
  // Calculate dimensions based on lat/lng ratio to fill container
  const dataAspectRatio = lngRange / latRange;
  const containerAspectRatio = containerW / containerH;
  
  let W, H;
  if (dataAspectRatio > containerAspectRatio) {
    // Data is wider - fit to width
    W = containerW;
    H = Math.floor(W / dataAspectRatio);
    // But ensure we fill height if result is too small
    if (H < containerH * 0.8) {
      H = containerH;
      W = Math.floor(H * dataAspectRatio);
    }
  } else {
    // Data is taller - fit to height
    H = containerH;
    W = Math.floor(H * dataAspectRatio);
    // But ensure we fill width if result is too small
    if (W < containerW * 0.8) {
      W = containerW;
      H = Math.floor(W / dataAspectRatio);
    }
  }
  
  // Safety check
  if (W <= 0 || H <= 0) {
    console.warn('Canvas dimensions invalid, skipping draw');
    return;
  }
  
  canvas.width = W * dpr;
  canvas.height = H * dpr;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.scale(dpr, dpr);

  ctx.fillStyle = '#0a0c0f';
  ctx.fillRect(0, 0, W, H);

  // Apply zoom and pan transform
  ctx.save();
  const zoom = canvas === mapCanvas ? mapZoom : 1;
  const offsetX = canvas === mapCanvas ? mapOffsetX : 0;
  const offsetY = canvas === mapCanvas ? mapOffsetY : 0;
  ctx.translate(W/2, H/2);
  ctx.scale(zoom, zoom);
  ctx.translate(-W/2 + offsetX, -H/2 + offsetY);

  // Sample the terrain and find min/max elevation for color mapping
  // Keep consistent resolution by sampling the visible area only
  // Calculate how much of the original area we're viewing after zoom
  const viewLatRange = latRange / zoom;
  const viewLngRange = lngRange / zoom;
  
  // Base density gives good quality, we keep it constant for consistent appearance
  const baseDensity = 250;
  // Sample based on the view area, not the full area
  const sampleDensity = baseDensity;
  
  const samples = [];
  let minElev = Infinity, maxElev = -Infinity;
  
  // Calculate the actual visible area after zoom and pan
  const viewCenterLat = minLat + latRange / 2;
  const viewCenterLng = minLng + lngRange / 2;
  const viewMinLat = viewCenterLat - viewLatRange / 2 - (mapOffsetY / H) * viewLatRange;
  const viewMaxLat = viewCenterLat + viewLatRange / 2 - (mapOffsetY / H) * viewLatRange;
  const viewMinLng = viewCenterLng - viewLngRange / 2 + (mapOffsetX / W) * viewLngRange;
  const viewMaxLng = viewCenterLng + viewLngRange / 2 + (mapOffsetX / W) * viewLngRange;
  
  for (let y = 0; y < sampleDensity; y++) {
    for (let x = 0; x < sampleDensity; x++) {
      // Sample the actual visible area
      const lat = viewMinLat + (viewLatRange * (sampleDensity - y) / sampleDensity);
      const lng = viewMinLng + (viewLngRange * x / sampleDensity);
      const elev = getElevation(lat, lng);
      if (elev !== null) {
        minElev = Math.min(minElev, elev);
        maxElev = Math.max(maxElev, elev);
        // Store canvas coordinates
        const canvasX = ((lng - minLng) / lngRange) * W;
        const canvasY = ((maxLat - lat) / latRange) * H;
        samples.push({ x: canvasX, y: canvasY, elev });
      }
    }
  }

  const elevRange = maxElev - minElev || 1;

  // Draw elevation as colored pixels
  const pixelSize = Math.max(Math.ceil(W / sampleDensity) * zoom, 1) + 1;
  samples.forEach(s => {
    const norm = (s.elev - minElev) / elevRange;
    const color = getElevationColor(norm);
    ctx.fillStyle = color;
    ctx.fillRect(s.x, s.y, pixelSize, pixelSize);
  });

  // Draw grid for tile boundaries
  ctx.strokeStyle = 'rgba(78,159,255,0.3)';
  ctx.lineWidth = 1;
  for (let lat = Math.ceil(minLat); lat <= maxLat; lat++) {
    const py = H * (1 - (lat - minLat) / latRange);
    ctx.beginPath();
    ctx.moveTo(0, py);
    ctx.lineTo(W, py);
    ctx.stroke();
  }
  for (let lng = Math.ceil(minLng); lng <= maxLng; lng++) {
    const px = W * (lng - minLng) / lngRange;
    ctx.beginPath();
    ctx.moveTo(px, 0);
    ctx.lineTo(px, H);
    ctx.stroke();
  }

  // Draw center marker and radial sight lines for radial view
  if (centerLat !== null && centerLng !== null) {
    const cx = W * (centerLng - minLng) / lngRange;
    const cy = H * (1 - (centerLat - minLat) / latRange);
    
    // Draw radial sight lines if data exists
    if (radialData && radialData.length > 0) {
      ctx.save();
      ctx.strokeStyle = 'rgba(78,255,160,0.4)';
      ctx.lineWidth = 1;
      
      radialData.forEach(ray => {
        if (!ray.visible) {
          ctx.strokeStyle = 'rgba(255,92,92,0.4)';
        } else {
          ctx.strokeStyle = 'rgba(78,255,160,0.4)';
        }
        
        const endPoint = destPoint(centerLat, centerLng, ray.bearing, ray.visibleDist);
        const ex = W * (endPoint.lng - minLng) / lngRange;
        const ey = H * (1 - (endPoint.lat - minLat) / latRange);
        
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        
        // Draw endpoint marker
        ctx.beginPath();
        ctx.arc(ex, ey, 2, 0, Math.PI*2);
        ctx.fillStyle = ray.visible ? 'rgba(78,255,160,0.8)' : 'rgba(255,92,92,0.8)';
        ctx.fill();
      });
      ctx.restore();
    }
    
    // Draw center marker on top
    ctx.beginPath();
    ctx.arc(cx, cy, 6, 0, Math.PI*2);
    ctx.fillStyle = '#ffb340';
    ctx.fill();
    ctx.strokeStyle = '#0a0c0f';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  ctx.restore();

  // Store map parameters for coordinate lookup
  canvas._mapParams = { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY };

  if (canvas === mapCanvas) {
    document.getElementById('mapInfo').textContent = 
      `Tiles: ${tileKeys.length} | Lat: ${minLat.toFixed(2)}° to ${maxLat.toFixed(2)}° | Lng: ${minLng.toFixed(2)}° to ${maxLng.toFixed(2)}° | Elev: ${Math.round(minElev)}m to ${Math.round(maxElev)}m | Samples: ${sampleDensity}x${sampleDensity}`;
    document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';
    terrainMapPanel.classList.add('visible');
    drawMinimap(minLat, maxLat, minLng, maxLng, latRange, lngRange);
  }
}

function drawMinimap(minLat, maxLat, minLng, maxLng, latRange, lngRange) {
  const W = 120, H = 80;
  minimapCanvas.width = W;
  minimapCanvas.height = H;
  
  mmctx.fillStyle = '#0a0c0f';
  mmctx.fillRect(0, 0, W, H);
  
  // Draw simplified terrain
  const density = 40;
  for (let y = 0; y < density; y++) {
    for (let x = 0; x < density; x++) {
      const lat = minLat + (latRange * (density - y) / density);
      const lng = minLng + (lngRange * x / density);
      const elev = getElevation(lat, lng);
      if (elev !== null) {
        const norm = Math.max(0, Math.min(1, elev / 3000)); // Simple normalization
        const color = getElevationColor(norm);
        mmctx.fillStyle = color;
        mmctx.fillRect(x * W / density, y * H / density, Math.ceil(W / density) + 1, Math.ceil(H / density) + 1);
      }
    }
  }
  
  // Draw viewport rectangle
  const viewW = W / mapZoom;
  const viewH = H / mapZoom;
  const viewX = W/2 - viewW/2 - mapOffsetX * W / (latRange * 111.32 * mapZoom);
  const viewY = H/2 - viewH/2 - mapOffsetY * H / (lngRange * 111.32 * mapZoom);
  
  mmctx.strokeStyle = '#4e9fff';
  mmctx.lineWidth = 1.5;
  mmctx.strokeRect(viewX, viewY, viewW, viewH);
}

function getElevationColor(norm) {
  // Color gradient from low (blue) to high (red/white)
  if (norm < 0.2) {
    const t = norm / 0.2;
    return `rgb(${Math.round(20 + t*30)}, ${Math.round(40 + t*80)}, ${Math.round(80 + t*100)})`;
  } else if (norm < 0.4) {
    const t = (norm - 0.2) / 0.2;
    return `rgb(${Math.round(50 + t*40)}, ${Math.round(120 + t*60)}, ${Math.round(180 - t*80)})`;
  } else if (norm < 0.6) {
    const t = (norm - 0.4) / 0.2;
    return `rgb(${Math.round(90 + t*70)}, ${Math.round(180 - t*60)}, ${Math.round(100 - t*60)})`;
  } else if (norm < 0.8) {
    const t = (norm - 0.6) / 0.2;
    return `rgb(${Math.round(160 + t*50)}, ${Math.round(120 + t*40)}, ${Math.round(40 + t*20)})`;
  } else {
    const t = (norm - 0.8) / 0.2;
    return `rgb(${Math.round(210 + t*45)}, ${Math.round(160 + t*95)}, ${Math.round(60 + t*195)})`;
  }
}

// Terrain map interaction handlers
function setupMapInteractions(canvas, hoverInfo, isRadial = false) {
  const hoverLatEl = hoverInfo.querySelector(isRadial ? '#radHoverLat' : '#hoverLat');
  const hoverLngEl = hoverInfo.querySelector(isRadial ? '#radHoverLng' : '#hoverLng');
  const hoverElevEl = hoverInfo.querySelector(isRadial ? '#radHoverElev' : '#hoverElev');
  let frozen = false;

  canvas.addEventListener('mousemove', e => {
    if (frozen) return;
    if (!canvas._mapParams) return;
    
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY } = canvas._mapParams;
    
    // Inverse transform to get map coordinates
    const tx = (mx - W/2) / zoom - offsetX + W/2;
    const ty = (my - H/2) / zoom - offsetY + H/2;
    
    if (tx < 0 || tx > W || ty < 0 || ty > H) {
      hoverInfo.classList.remove('visible');
      return;
    }
    
    const lng = minLng + (tx / W) * lngRange;
    const lat = minLat + (1 - ty / H) * latRange;
    const elev = getElevation(lat, lng);
    
    if (elev !== null) {
      hoverLatEl.textContent = lat.toFixed(5) + '°';
      hoverLngEl.textContent = lng.toFixed(5) + '°';
      hoverElevEl.textContent = Math.round(elev) + ' m';
      hoverInfo.style.left = (mx + 14) + 'px';
      hoverInfo.style.top = (my - 60) + 'px';
      hoverInfo.classList.add('visible');
    } else {
      hoverInfo.classList.remove('visible');
    }
  });

  canvas.addEventListener('mouseleave', () => {
    if (!frozen) hoverInfo.classList.remove('visible');
  });

  canvas.addEventListener('click', () => {
    frozen = !frozen;
    if (frozen) {
      hoverInfo.classList.add('frozen');
    } else {
      hoverInfo.classList.remove('frozen');
      hoverInfo.classList.remove('visible');
    }
  });

  // Pan functionality (only for main map)
  if (!isRadial) {
    canvas.addEventListener('mousedown', e => {
      mapIsPanning = true;
      mapLastX = e.clientX;
      mapLastY = e.clientY;
      canvas.classList.add('panning');
    });

    canvas.addEventListener('mousemove', e => {
      if (!mapIsPanning) return;
      const dx = e.clientX - mapLastX;
      const dy = e.clientY - mapLastY;
      mapOffsetX += dx / mapZoom;
      mapOffsetY += dy / mapZoom;
      mapLastX = e.clientX;
      mapLastY = e.clientY;
      drawTerrainMap();
    });

    canvas.addEventListener('mouseup', () => {
      mapIsPanning = false;
      canvas.classList.remove('panning');
    });

    canvas.addEventListener('mouseleave', () => {
      mapIsPanning = false;
      canvas.classList.remove('panning');
    });

    // Zoom with mouse wheel
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      mapZoom *= zoomFactor;
      mapZoom = Math.max(0.5, Math.min(10, mapZoom));
      drawTerrainMap();
    });
  }
}

setupMapInteractions(mapCanvas, mapHoverInfo, false);
if (radMapCanvas) setupMapInteractions(radMapCanvas, radMapHoverInfo, true);

// Minimap click to navigate
minimapCanvas.addEventListener('click', e => {
  const rect = minimapCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  
  if (!mapCanvas._mapParams) return;
  const { W, H, latRange, lngRange } = mapCanvas._mapParams;
  
  // Calculate new offset to center on clicked point
  const targetX = (x - 0.5) * W;
  const targetY = (y - 0.5) * H;
  mapOffsetX = -targetX;
  mapOffsetY = -targetY;
  drawTerrainMap();
});

// Map control buttons
document.getElementById('btnResetZoom')?.addEventListener('click', () => {
  mapZoom = 1;
  mapOffsetX = 0;
  mapOffsetY = 0;
  drawTerrainMap();
});

document.getElementById('btnSaveTiles')?.addEventListener('click', saveTilesToStorage);
document.getElementById('btnLoadTiles')?.addEventListener('click', loadTilesFromStorage);

function renderTileTags() {
  tileList.innerHTML = '';
  Object.keys(tiles).forEach(key => {
    const t   = tiles[key];
    const tag = document.createElement('div');
    tag.className = 'tile-tag';
    tag.innerHTML = `<span class="tag-name">${key}</span><span class="tag-res">${t.size === 1201 ? '3″' : '1″'}</span><span class="tag-remove" data-key="${key}">✕</span>`;
    tileList.appendChild(tag);
  });
  tileList.querySelectorAll('.tag-remove').forEach(el => {
    el.addEventListener('click', () => { delete tiles[el.dataset.key]; renderTileTags(); updateBtn(); });
  });
}

/* ═══════════════════════════════════════════════════════════
   ELEVATION LOOKUP  (bilinear)
   ═══════════════════════════════════════════════════════════ */
function getElevation(lat, lng) {
  const latBase = Math.floor(lat);
  const lngBase = Math.floor(lng);
  const key     = tileKeyFromCoord(latBase, lngBase);
  const tile    = tiles[key];
  if (!tile) return null;

  const size = tile.size;
  const res  = 1 / (size - 1);
  const rowF = (latBase + 1 - lat) / res;
  const colF = (lng - lngBase)     / res;

  const r0 = Math.floor(rowF), c0 = Math.floor(colF);
  const r1 = Math.min(r0 + 1, size - 1), c1 = Math.min(c0 + 1, size - 1);
  const fr = rowF - r0, fc = colF - c0;

  const idx = (r, c) => r * size + c;
  const v00 = tile.data[idx(r0, c0)];
  const v10 = tile.data[idx(r1, c0)];
  const v01 = tile.data[idx(r0, c1)];
  const v11 = tile.data[idx(r1, c1)];

  if (v00 === -32768 || v10 === -32768 || v01 === -32768 || v11 === -32768) return null;

  return v00*(1-fr)*(1-fc) + v10*fr*(1-fc) + v01*(1-fr)*fc + v11*fr*fc;
}

/* ═══════════════════════════════════════════════════════════
   GEO HELPERS
   ═══════════════════════════════════════════════════════════ */
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
const EARTH_R = 6371; // km

function haversine(lat1, lng1, lat2, lng2) {
  const dLat = (lat2-lat1)*DEG2RAD, dLng = (lng2-lng1)*DEG2RAD;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*DEG2RAD)*Math.cos(lat2*DEG2RAD)*Math.sin(dLng/2)**2;
  return EARTH_R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function interpolateLine(lat1, lng1, lat2, lng2, t) {
  return { lat: lat1+(lat2-lat1)*t, lng: lng1+(lng2-lng1)*t };
}

// Given a centre, bearing (deg, 0=N cw), distance in km → destination lat/lng
function destPoint(lat, lng, bearingDeg, distKm) {
  const lat1 = lat * DEG2RAD;
  const lng1 = lng * DEG2RAD;
  const brng = bearingDeg * DEG2RAD;
  const d    = distKm / EARTH_R;

  const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(brng));
  const lng2 = lng1 + Math.atan2(Math.sin(brng)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
  return { lat: lat2 * RAD2DEG, lng: lng2 * RAD2DEG };
}

/* ═══════════════════════════════════════════════════════════
   LINE-OF-SIGHT CHECK  (single ray)
   Returns { visible: bool, visibleDist: km, blockElev: m|null, blockDist: km|null }
   ═══════════════════════════════════════════════════════════ */
function checkLOS(obsLat, obsLng, obsElev, targetLat, targetLng, samples) {
  const totalDist = haversine(obsLat, obsLng, targetLat, targetLng);
  // elevation of the target
  const targElev = getElevation(targetLat, targetLng);

  let maxSlope = -Infinity;   // max slope seen so far (rise / run in m / m)
  let blockDist = null, blockElev = null;

  for (let i = 1; i <= samples; i++) {
    const t     = i / samples;
    const pt    = interpolateLine(obsLat, obsLng, targetLat, targetLng, t);
    const elev  = getElevation(pt.lat, pt.lng);
    if (elev === null) continue;

    const d = totalDist * t * 1000; // metres along path
    if (d === 0) continue;

    // slope from observer to this sample
    const slope = (elev - obsElev) / d;

    if (slope > maxSlope) {
      maxSlope = slope;
    }

    // The point is blocked if its elevation is above the line of sight
    // drawn from observer with the current max slope
    // i.e. if this point itself creates a *new* max slope, it might be the blocker for later points
  }

  // Second pass: walk forward, track max slope = the "horizon". If any later point is above that horizon it is blocked.
  maxSlope = -Infinity;
  let lastVisibleDist = 0;

  for (let i = 1; i <= samples; i++) {
    const t    = i / samples;
    const pt   = interpolateLine(obsLat, obsLng, targetLat, targetLng, t);
    const elev = getElevation(pt.lat, pt.lng);
    if (elev === null) continue;

    const d     = totalDist * t * 1000; // metres
    const slope = (elev - obsElev) / d;

    if (slope > maxSlope) {
      // this point is on or above the horizon → visible, and becomes new horizon
      maxSlope = slope;
      lastVisibleDist = totalDist * t; // km
    }
    // if slope <= maxSlope the point is below the current horizon → blocked by earlier ridge
  }

  // target is visible if the target's own slope >= maxSlope established before it
  // Simpler: re-walk and check the target specifically
  let horizonBeforeTarget = -Infinity;
  for (let i = 1; i < samples; i++) {
    const t    = i / samples;
    const pt   = interpolateLine(obsLat, obsLng, targetLat, targetLng, t);
    const elev = getElevation(pt.lat, pt.lng);
    if (elev === null) continue;
    const d = totalDist * t * 1000;
    const slope = (elev - obsElev) / d;
    if (slope > horizonBeforeTarget) horizonBeforeTarget = slope;
  }

  const targSlope = targElev !== null ? (targElev - obsElev) / (totalDist * 1000) : null;
  const visible = targElev !== null && targSlope >= horizonBeforeTarget;

  if (!visible && targElev !== null) {
    // find the first blocker: the sample that set the horizon above the target slope
    let runningMax = -Infinity;
    for (let i = 1; i < samples; i++) {
      const t    = i / samples;
      const pt   = interpolateLine(obsLat, obsLng, targetLat, targetLng, t);
      const elev = getElevation(pt.lat, pt.lng);
      if (elev === null) continue;
      const d = totalDist * t * 1000;
      const slope = (elev - obsElev) / d;
      if (slope > runningMax) {
        runningMax = slope;
        if (runningMax > targSlope) {
          blockDist = totalDist * t;
          blockElev = elev;
          break;
        }
      }
    }
  }

  return {
    visible,
    visibleDist: visible ? totalDist : (blockDist || lastVisibleDist),
    blockElev,
    blockDist
  };
}

/* ═══════════════════════════════════════════════════════════
   TOWER HEIGHT CALCULATIONS
   ═══════════════════════════════════════════════════════════ */
function calculateMinTowerHeights(profileData, treeHeight = 5) {
  // Calculate minimum tower height at each point to get LOS from that point to end
  const n = profileData.length;
  const minHeights = new Array(n).fill(0);
  
  if (n < 2) return minHeights;
  
  // For each point, calculate the height needed to see the end point
  const endIdx = n - 1;
  const endElev = profileData[endIdx].elev;
  const endDist = profileData[endIdx].dist;
  
  for (let i = 0; i < n; i++) {
    if (profileData[i].elev === null) continue;
    
    let requiredHeight = 0;
    const iElev = profileData[i].elev + treeHeight;
    const iDist = profileData[i].dist;
    
    // Check all points between i and end
    for (let j = i + 1; j < n; j++) {
      if (profileData[j].elev === null) continue;
      
      const jElev = profileData[j].elev + (j === endIdx ? 0 : treeHeight);
      const jDist = profileData[j].dist;
      
      // Line from i to end
      const lineSlope = (endElev - iElev) / (endDist - iDist);
      const lineElevAtJ = iElev + lineSlope * (jDist - iDist);
      
      // If terrain at j is above the line, we need more height at i
      if (jElev > lineElevAtJ) {
        const deficit = jElev - lineElevAtJ;
        requiredHeight = Math.max(requiredHeight, deficit);
      }
    }
    
    minHeights[i] = requiredHeight;
  }
  
  return minHeights;
}

function calculateOptimalTowerHeights(profileData, treeHeight = 5) {
  // Calculate optimal tower heights at start and end to minimize TOTAL height (start + end)
  const n = profileData.length;
  if (n < 2) return { startHeight: 0, endHeight: 0, totalHeight: 0 };
  
  const startElev = profileData[0].elev || 0;
  const endElev = profileData[n - 1].elev || 0;
  const totalDist = profileData[n - 1].dist;
  
  let minTotalHeight = Infinity;
  let bestStart = 0, bestEnd = 0;
  
  // Binary search / optimization for minimum total height
  // For each possible total height, find if there's a valid split
  for (let totalH = 0; totalH <= 200; totalH += 0.5) {
    // Try different splits of this total height
    for (let startH = 0; startH <= totalH; startH += 0.5) {
      const endH = totalH - startH;
      
      // Check if this combination gives LOS
      const p1Elev = startElev + startH;
      const p2Elev = endElev + endH;
      let clearLOS = true;
      
      for (let i = 1; i < n - 1; i++) {
        if (profileData[i].elev === null) continue;
        
        const dist = profileData[i].dist;
        const terrainElev = profileData[i].elev + treeHeight;
        
        // Height of LOS line at this point
        const t = dist / totalDist;
        const losElev = p1Elev + (p2Elev - p1Elev) * t;
        
        if (terrainElev > losElev) {
          clearLOS = false;
          break;
        }
      }
      
      if (clearLOS) {
        if (totalH < minTotalHeight) {
          minTotalHeight = totalH;
          bestStart = startH;
          bestEnd = endH;
        }
        break; // Found a valid split for this total, no need to try more
      }
    }
    
    // Early exit if we found a solution
    if (minTotalHeight < Infinity) {
      break;
    }
  }
  
  return { startHeight: bestStart, endHeight: bestEnd, totalHeight: minTotalHeight };
}

/* ═══════════════════════════════════════════════════════════
   GENERATE  (dispatcher)
   ═══════════════════════════════════════════════════════════ */
btnGen.addEventListener('click', () => {
  if (currentMode === 'ab') generateProfile();
  else                      generateRadial();
});

document.getElementById('btnUpdateProfile')?.addEventListener('click', () => {
  if (profileData.length > 0) {
    drawProfile(cachedLOS);
  }
});

// Add change listeners to checkboxes to auto-update
['showLOS', 'showUserTowers', 'showMinTowers', 'showOptimalTowers'].forEach(id => {
  document.getElementById(id)?.addEventListener('change', () => {
    if (profileData.length > 0) drawProfile(cachedLOS);
  });
});

// Add input listeners for tower/tree heights to auto-update
['startTowerHeight', 'endTowerHeight', 'treeHeight'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      if (profileData.length > 0) drawProfile(cachedLOS);
    });
  }
});

/* ═══════════════════════════════════════════════════════════
   A → B  PROFILE
   ═══════════════════════════════════════════════════════════ */
function generateProfile() {
  const sLat = parseFloat(document.getElementById('startLat').value);
  const sLng = parseFloat(document.getElementById('startLng').value);
  const eLat = parseFloat(document.getElementById('endLat').value);
  const eLng = parseFloat(document.getElementById('endLng').value);

  if ([sLat, sLng, eLat, eLng].some(isNaN)) { setStatus('All coordinate fields are required.', true); return; }
  if (sLat<-90||sLat>90||eLat<-90||eLat>90) { setStatus('Latitude must be −90 … 90.', true); return; }
  if (sLng<-180||sLng>180||eLng<-180||eLng>180) { setStatus('Longitude must be −180 … 180.', true); return; }

  const N    = parseInt(document.getElementById('sampleCount').value);
  const dist = haversine(sLat, sLng, eLat, eLng);
  profileData = [];
  let voidCount = 0;

  for (let i = 0; i <= N; i++) {
    const t    = i / N;
    const pt   = interpolateLine(sLat, sLng, eLat, eLng, t);
    const elev = getElevation(pt.lat, pt.lng);
    const d    = dist * t;
    if (elev === null) { voidCount++; profileData.push({ dist: d, elev: null }); }
    else               { profileData.push({ dist: d, elev }); }
  }

  if (profileData.every(p => p.elev === null)) { setStatus('No elevation data — check tiles are loaded.', true); return; }

  // LOS check: observer = start elevation, target = end elevation
  const startElev = profileData.find(p => p.elev !== null)?.elev ?? 0;
  const losResult = checkLOS(sLat, sLng, startElev, eLat, eLng, N);

  if (voidCount > 0) setStatus(`Profile generated · ${voidCount} void samples skipped.`, false);
  else               setStatus(`Profile generated · ${N+1} samples · ${dist.toFixed(2)} km`, false);

  cachedLOS = losResult;
  updateProfileStats(dist, losResult);
  radialPanel.classList.remove('visible');
  profilePanel.classList.add('visible');
  drawProfile(losResult);
}

function updateProfileStats(dist, los) {
  const elevs = profileData.filter(p => p.elev !== null).map(p => p.elev);
  document.getElementById('statDist').innerHTML  = `${dist.toFixed(2)}<span class="unit">km</span>`;
  document.getElementById('statMax').innerHTML   = `${Math.round(Math.max(...elevs))}<span class="unit">m</span>`;
  document.getElementById('statMin').innerHTML   = `${Math.round(Math.min(...elevs))}<span class="unit">m</span>`;
  document.getElementById('statStart').innerHTML = `${profileData[0].elev !== null ? Math.round(profileData[0].elev) : '—'}<span class="unit">m</span>`;
  document.getElementById('statEnd').innerHTML   = `${profileData[profileData.length-1].elev !== null ? Math.round(profileData[profileData.length-1].elev) : '—'}<span class="unit">m</span>`;
  const losEl = document.getElementById('statLOS');
  if (los.visible) losEl.innerHTML = `<span style="color:var(--accent-green)">Clear</span>`;
  else             losEl.innerHTML = `<span style="color:var(--danger)">Blocked @ ${los.blockDist ? los.blockDist.toFixed(2) : '?'}<span class="unit">km</span></span>`;
}

/* ─── DRAW PROFILE ─────────────────────────────────────── */
function drawProfile(los) {
  const dpr  = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const W    = rect.width || 1060;
  const H    = 320;
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  ctx.scale(dpr, dpr);

  const pad = { top: 30, right: 28, bottom: 40, left: 62 };
  const pw  = W - pad.left - pad.right;
  const ph  = H - pad.top  - pad.bottom;

  const validPoints = profileData.filter(p => p.elev !== null);
  const maxDist  = profileData[profileData.length-1].dist;
  const minElev  = Math.min(...validPoints.map(p => p.elev));
  const maxElev  = Math.max(...validPoints.map(p => p.elev));
  const elevRange= maxElev - minElev || 1;
  const padElev  = elevRange * 0.06;

  const toX = d => pad.left + (d / maxDist) * pw;
  const toY = e => pad.top  + ph - ((e - minElev + padElev) / (elevRange + padElev*2)) * ph;

  ctx.clearRect(0, 0, W, H);

  /* grid */
  ctx.save();
  ctx.font = '10px "IBM Plex Mono", monospace';
  ctx.fillStyle = '#606878';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  const elevStep  = niceStep(elevRange / 4);
  const elevStart = Math.floor((minElev - padElev) / elevStep) * elevStep;
  for (let e = elevStart; e <= maxElev + padElev; e += elevStep) {
    const y = toY(e);
    if (y < pad.top || y > H-pad.bottom) continue;
    ctx.strokeStyle = (e%(elevStep*2)===0) ? 'rgba(78,159,255,0.15)' : 'rgba(78,159,255,0.07)';
    ctx.lineWidth = 0.7;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W-pad.right, y); ctx.stroke();
    ctx.fillText(Math.round(e)+' m', pad.left-8, y);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  const distStep = niceStep(maxDist / 5);
  for (let d = 0; d <= maxDist; d += distStep) {
    const x = toX(d);
    ctx.strokeStyle = 'rgba(78,159,255,0.07)';
    ctx.lineWidth = 0.7;
    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, H-pad.bottom); ctx.stroke();
    ctx.fillStyle = '#606878';
    ctx.fillText(d.toFixed(1)+' km', x, H-pad.bottom+6);
  }
  ctx.restore();

  /* filled area */
  const grad = ctx.createLinearGradient(0, pad.top, 0, H-pad.bottom);
  grad.addColorStop(0, 'rgba(78,159,255,0.40)');
  grad.addColorStop(1, 'rgba(78,159,255,0.02)');

  ctx.beginPath();
  let started = false;
  profileData.forEach(p => {
    if (p.elev === null) { started = false; return; }
    const x = toX(p.dist), y = toY(p.elev);
    if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
  });
  const lastValid  = [...profileData].reverse().find(p => p.elev !== null);
  const firstValid = profileData.find(p => p.elev !== null);
  if (lastValid && firstValid) {
    ctx.lineTo(toX(lastValid.dist), H-pad.bottom);
    ctx.lineTo(toX(firstValid.dist), H-pad.bottom);
    ctx.closePath();
  }
  ctx.fillStyle = grad;
  ctx.fill();

  /* terrain stroke */
  ctx.beginPath();
  started = false;
  profileData.forEach(p => {
    if (p.elev === null) { started = false; return; }
    const x = toX(p.dist), y = toY(p.elev);
    if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
  });
  ctx.strokeStyle = '#4e9fff';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.stroke();

  /* ─── TOWER HEIGHT LINES ─── */
  const showLOS = document.getElementById('showLOS')?.checked ?? true;
  const showUserTowers = document.getElementById('showUserTowers')?.checked;
  const showMinTowers = document.getElementById('showMinTowers')?.checked;
  const showOptimalTowers = document.getElementById('showOptimalTowers')?.checked;
  const treeHeight = parseFloat(document.getElementById('treeHeight')?.value || 5);
  
  // Draw tree height offset as filled area
  if (treeHeight > 0) {
    ctx.save();
    const treeGrad = ctx.createLinearGradient(0, pad.top, 0, H-pad.bottom);
    treeGrad.addColorStop(0, 'rgba(34,139,34,0.2)');
    treeGrad.addColorStop(1, 'rgba(34,139,34,0.05)');
    
    ctx.beginPath();
    let started = false;
    profileData.forEach(p => {
      if (p.elev === null) { started = false; return; }
      const x = toX(p.dist), y = toY(p.elev + treeHeight);
      if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    // Close the path along terrain
    const reversed = [...profileData].reverse();
    reversed.forEach(p => {
      if (p.elev === null) return;
      const x = toX(p.dist), y = toY(p.elev);
      ctx.lineTo(x,y);
    });
    ctx.closePath();
    ctx.fillStyle = treeGrad;
    ctx.fill();
    
    // Draw tree height line
    ctx.strokeStyle = 'rgba(34,139,34,0.6)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 2]);
    ctx.beginPath();
    started = false;
    profileData.forEach(p => {
      if (p.elev === null) { started = false; return; }
      const x = toX(p.dist), y = toY(p.elev + treeHeight);
      if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.restore();
  }

  // Draw user-defined tower heights
  if (showUserTowers && firstValid && lastValid) {
    const startTowerH = parseFloat(document.getElementById('startTowerHeight')?.value || 10);
    const endTowerH = parseFloat(document.getElementById('endTowerHeight')?.value || 10);
    
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startTowerH);
    const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev + endTowerH);

    ctx.save();
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = '#ffb340';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
    
    // Draw tower verticals
    ctx.save();
    ctx.strokeStyle = '#ffb340';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  // Draw minimum tower heights: line from start tower to end point, and end tower to start point
  if (showMinTowers && firstValid && lastValid) {
    // Calculate height needed at start to see end
    let startHeightNeeded = 0;
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeHeight;
      const totalDist = lastValid.dist - firstValid.dist;
      const lineElev = firstValid.elev + (lastValid.elev - firstValid.elev) * (iDist - firstValid.dist) / totalDist;
      if (iElev > lineElev) {
        startHeightNeeded = Math.max(startHeightNeeded, iElev - lineElev);
      }
    }

    // Calculate height needed at end to see start
    let endHeightNeeded = 0;
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeHeight;
      const totalDist = lastValid.dist - firstValid.dist;
      const lineElev = lastValid.elev + (firstValid.elev - lastValid.elev) * (lastValid.dist - iDist) / totalDist;
      if (iElev > lineElev) {
        endHeightNeeded = Math.max(endHeightNeeded, iElev - lineElev);
      }
    }

    ctx.save();
    
    // Line from start tower to end
    if (startHeightNeeded > 0) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startHeightNeeded);
      const x2 = toX(lastValid.dist), y2 = toY(lastValid.elev);
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = 'rgba(255,179,64,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Tower vertical
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255,179,64,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      
      // Label
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = 'rgba(255,179,64,1)';
      ctx.textAlign = 'left';
      ctx.fillText(`${startHeightNeeded.toFixed(1)}m`, x1 + 5, y1);
    }
    
    // Line from end tower to start
    if (endHeightNeeded > 0) {
      const x1 = toX(lastValid.dist), y1 = toY(lastValid.elev + endHeightNeeded);
      const x2 = toX(firstValid.dist), y2 = toY(firstValid.elev);
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = 'rgba(255,140,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Tower vertical
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255,140,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      
      // Label
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = 'rgba(255,140,100,1)';
      ctx.textAlign = 'right';
      ctx.fillText(`${endHeightNeeded.toFixed(1)}m`, x1 - 5, y1);
    }
    
    ctx.restore();
  }

  // Draw optimal combined tower heights
  if (showOptimalTowers && firstValid && lastValid) {
    const optimal = calculateOptimalTowerHeights(profileData, treeHeight);
    
    if (optimal.totalHeight < Infinity) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + optimal.startHeight);
      const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev + optimal.endHeight);

      ctx.save();
      ctx.setLineDash([8, 3]);
      ctx.strokeStyle = '#4effa0';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
      
      // Draw tower verticals
      ctx.save();
      ctx.strokeStyle = '#4effa0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
      
      // Add label
      ctx.save();
      ctx.font = '11px "IBM Plex Mono", monospace';
      ctx.fillStyle = '#4effa0';
      ctx.textAlign = 'center';
      ctx.fillText(`Optimal: ${optimal.startHeight.toFixed(1)}m + ${optimal.endHeight.toFixed(1)}m`, (x1+x2)/2, Math.min(y1,y2) - 10);
      ctx.restore();
    }
  }

  /* ─── LINE OF SIGHT between start and end ─── */
  if (showLOS && firstValid && lastValid) {
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev);
    const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev);

    // dashed style, colour depends on visibility
    ctx.save();
    ctx.setLineDash([8, 5]);
    ctx.lineDashOffset = 0;

    if (los && los.visible) {
      ctx.strokeStyle = 'rgba(78,255,160,0.7)';
    } else {
      ctx.strokeStyle = 'rgba(255,92,92,0.7)';
    }
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();

    // If blocked, mark the block point
    if (los && !los.visible && los.blockDist !== null && los.blockElev !== null) {
      const bx = toX(los.blockDist);
      // the LOS line y at that x
      const losYatBlock = y1 + (y2-y1) * ((los.blockDist - firstValid.dist) / (lastValid.dist - firstValid.dist));
      // draw a small cross at the block point on the terrain
      const by = toY(los.blockElev);
      ctx.save();
      ctx.strokeStyle = var_danger();
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(bx-6, by-6); ctx.lineTo(bx+6, by+6);
      ctx.moveTo(bx+6, by-6); ctx.lineTo(bx-6, by+6);
      ctx.stroke();
      ctx.restore();
    }
  }

  /* start / end dots */
  if (firstValid) {
    ctx.beginPath();
    ctx.arc(toX(firstValid.dist), toY(firstValid.elev), 5, 0, Math.PI*2);
    ctx.fillStyle = '#4effa0'; ctx.fill();
    ctx.strokeStyle = '#0a0c0f'; ctx.lineWidth = 2.5; ctx.stroke();
  }
  if (lastValid) {
    ctx.beginPath();
    ctx.arc(toX(lastValid.dist), toY(lastValid.elev), 5, 0, Math.PI*2);
    ctx.fillStyle = '#ffb340'; ctx.fill();
    ctx.strokeStyle = '#0a0c0f'; ctx.lineWidth = 2.5; ctx.stroke();
  }

  canvas._drawParams = { pad, pw, ph, toX, toY, minElev, maxElev, maxDist, elevRange, padElev };
}

function var_danger() { return '#ff5c5c'; }

/* ─── PROFILE TOOLTIP ──────────────────────────────────── */
canvas.addEventListener('mousemove', e => {
  if (!canvas._drawParams || !profileData.length) return;
  const rect = canvas.getBoundingClientRect();
  const mx   = e.clientX - rect.left;
  const { pad, maxDist } = canvas._drawParams;
  const pw = rect.width - pad.left - pad.right;
  const d  = ((mx - pad.left) / pw) * maxDist;
  if (d < 0 || d > maxDist) { tooltip.classList.remove('visible'); return; }

  let closest = null, bestDiff = Infinity;
  profileData.forEach(p => { if (p.elev===null) return; const diff=Math.abs(p.dist-d); if(diff<bestDiff){bestDiff=diff;closest=p;} });
  if (!closest) { tooltip.classList.remove('visible'); return; }

  document.getElementById('ttElev').textContent = Math.round(closest.elev)+' m';
  document.getElementById('ttDist').textContent = ' · '+closest.dist.toFixed(2)+' km';
  tooltip.style.left = (mx+14)+'px';
  tooltip.style.top  = (e.clientY - rect.top - 20)+'px';
  tooltip.classList.add('visible');
});
canvas.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));

/* ═══════════════════════════════════════════════════════════
   RADIAL LOS
   ═══════════════════════════════════════════════════════════ */
function generateRadial() {
  const lat     = parseFloat(document.getElementById('radLat').value);
  const lng     = parseFloat(document.getElementById('radLng').value);
  const radius  = parseFloat(document.getElementById('radRadius').value);
  const angRes  = parseFloat(document.getElementById('radAngRes').value);
  const samples = parseInt(document.getElementById('radSamples').value);
  const obsH    = parseFloat(document.getElementById('radObsHeight').value) || 0;
  const remoteH = parseFloat(document.getElementById('radMaxTowerHeight').value) || 0;
  const showHeatmap = document.getElementById('showRadialHeatmap')?.checked || false;

  if (isNaN(lat)||isNaN(lng)||isNaN(radius)) { setStatus('Lat, Lng and Radius are required.', true); return; }
  if (radius <= 0) { setStatus('Radius must be > 0.', true); return; }

  const obsElev = getElevation(lat, lng);
  if (obsElev === null) { setStatus('No elevation data at observer point — check tiles.', true); return; }

  const totalObsElev = obsElev + obsH;
  radialData = [];

  // cast rays
  const numRays = Math.round(360 / angRes);
  let visCount = 0, blkCount = 0;

  setStatus('Computing…', false);

  // use setTimeout(0) to let the status paint, then compute
  setTimeout(() => {
    if (showHeatmap) {
      // Heatmap mode: calculate minimum tower height needed for each bearing
      const maxTowerH = parseFloat(document.getElementById('radMaxTowerHeight')?.value || 50);
      
      for (let i = 0; i < numRays; i++) {
        const bearing = (i * angRes) % 360;
        const target  = destPoint(lat, lng, bearing, radius);
        const targetElev = getElevation(target.lat, target.lng) || 0;
        
        // Binary search for minimum tower height at remote end
        let minH = 0, maxH = maxTowerH;
        let requiredHeight = maxTowerH;
        
        for (let iter = 0; iter < 20; iter++) {
          const testH = (minH + maxH) / 2;
          const result = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, 0, targetElev + testH);
          
          if (result.visible) {
            requiredHeight = testH;
            maxH = testH;
          } else {
            minH = testH;
          }
        }
        
        radialData.push({
          bearing,
          visible: requiredHeight < maxTowerH,
          visibleDist: radius,
          blockElev: null,
          blockDist: null,
          requiredTowerHeight: requiredHeight
        });
        
        if (requiredHeight < maxTowerH) visCount++; else blkCount++;
      }
    } else {
      // Standard mode: use remote tower height
      for (let i = 0; i < numRays; i++) {
        const bearing = (i * angRes) % 360;
        const target  = destPoint(lat, lng, bearing, radius);
        const targetElev = getElevation(target.lat, target.lng) || 0;
        const result  = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, 0, targetElev + remoteH);

        radialData.push({
          bearing,
          visible:     result.visible,
          visibleDist: result.visibleDist,
          blockElev:   result.blockElev,
          blockDist:   result.blockDist
        });
        if (result.visible) visCount++; else blkCount++;
      }
    }

    setStatus(`Radial scan complete · ${numRays} rays · ${visCount} visible · ${blkCount} blocked`, false);

    // stats
    document.getElementById('rStatRadius').innerHTML  = `${radius.toFixed(1)}<span class="unit">km</span>`;
    document.getElementById('rStatRays').textContent   = numRays;
    document.getElementById('rStatVis').innerHTML     = `<span style="color:var(--accent-green)">${visCount}</span>`;
    document.getElementById('rStatBlk').innerHTML     = `<span style="color:var(--danger)">${blkCount}</span>`;
    document.getElementById('rStatObsElev').innerHTML = `${Math.round(totalObsElev)}<span class="unit">m</span>`;

    // Store params for terrain overlay
    lastRadialParams = { lat, lng, radius, obsElev: totalObsElev };

    profilePanel.classList.remove('visible');
    radialPanel.classList.add('visible');

    drawRadial(radius);
    populateRadialTable();
    // Draw terrain map with radial data available
    if (radMapCanvas) {
      drawTerrainMap(radMapCanvas, radMctx, lat, lng, radius);
    }
  }, 30);
}

function getTowerHeightColor(norm) {
  // Gradient from green (0m) to yellow (mid) to red (max)
  if (norm < 0.5) {
    const t = norm * 2;
    const r = Math.round(78 + t * 177);
    const g = Math.round(255);
    const b = Math.round(160 * (1 - t));
    return `rgba(${r},${g},${b},0.7)`;
  } else {
    const t = (norm - 0.5) * 2;
    const r = Math.round(255);
    const g = Math.round(255 * (1 - t));
    const b = Math.round(64 * (1 - t));
    return `rgba(${r},${g},${b},0.7)`;
  }
}

/* ─── DRAW RADIAL POLAR ────────────────────────────────── */
function drawRadial(radius) {
  const dpr  = window.devicePixelRatio || 1;
  const SIZE = 400;
  radCanvas.width  = SIZE * dpr;
  radCanvas.height = SIZE * dpr;
  radCanvas.style.width  = SIZE + 'px';
  radCanvas.style.height = SIZE + 'px';
  rctx.scale(dpr, dpr);

  const cx = SIZE / 2, cy = SIZE / 2;
  const R  = SIZE / 2 - 24;  // max draw radius (px)

  rctx.clearRect(0, 0, SIZE, SIZE);

  /* background circle */
  rctx.beginPath();
  rctx.arc(cx, cy, R, 0, Math.PI*2);
  rctx.fillStyle = 'rgba(10,12,15,0.6)';
  rctx.fill();
  rctx.strokeStyle = 'rgba(78,159,255,0.18)';
  rctx.lineWidth = 1;
  rctx.stroke();

  /* range rings */
  const ringCount = 4;
  rctx.save();
  rctx.font = '9px "IBM Plex Mono", monospace';
  rctx.fillStyle = '#606878';
  rctx.textAlign = 'center';
  rctx.textBaseline = 'middle';
  for (let i = 1; i <= ringCount; i++) {
    const r = R * (i / ringCount);
    rctx.beginPath();
    rctx.arc(cx, cy, r, 0, Math.PI*2);
    rctx.strokeStyle = (i === ringCount) ? 'rgba(78,159,255,0.2)' : 'rgba(78,159,255,0.08)';
    rctx.lineWidth = 0.7;
    rctx.stroke();
    // label
    const labelKm = (radius * i / ringCount).toFixed(1);
    rctx.fillText(labelKm + ' km', cx, cy - r + 10);
  }
  rctx.restore();

  /* cardinal labels */
  rctx.save();
  rctx.font = '11px "IBM Plex Mono", monospace';
  rctx.fillStyle = 'rgba(200,208,220,0.7)';
  rctx.textAlign = 'center';
  rctx.textBaseline = 'middle';
  rctx.fillText('N', cx, cy - R - 10);
  rctx.fillText('S', cx, cy + R + 10);
  rctx.textAlign = 'right';
  rctx.fillText('W', cx - R - 8, cy);
  rctx.textAlign = 'left';
  rctx.fillText('E', cx + R + 8, cy);
  rctx.restore();

  /* cardinal cross-hairs */
  rctx.save();
  rctx.strokeStyle = 'rgba(78,159,255,0.12)';
  rctx.lineWidth = 0.8;
  rctx.setLineDash([4,4]);
  [[cx,cy-R,cx,cy+R],[cx-R,cy,cx+R,cy]].forEach(([x1,y1,x2,y2]) => {
    rctx.beginPath(); rctx.moveTo(x1,y1); rctx.lineTo(x2,y2); rctx.stroke();
  });
  rctx.restore();

  /* ray wedges */
  const showHeatmap = document.getElementById('showRadialHeatmap')?.checked || false;
  const showTerrain = document.getElementById('showRadialTerrain')?.checked || false;
  const maxTowerH = parseFloat(document.getElementById('radMaxTowerHeight')?.value || 50);
  
  if (radialData.length > 0) {
    const halfAngle = (radialData.length > 1)
      ? (radialData[1].bearing - radialData[0].bearing) / 2 * DEG2RAD
      : 1 * DEG2RAD;

    radialData.forEach(ray => {
      // bearing 0 = North = up = -π/2 in canvas coords
      const angleCentre = (ray.bearing - 90) * DEG2RAD;
      const a1 = angleCentre - halfAngle;
      const a2 = angleCentre + halfAngle;

      // length proportional to visible dist / radius, clamped
      const frac = Math.min(ray.visibleDist / radius, 1);
      const len  = R * frac;

      rctx.beginPath();
      rctx.moveTo(cx, cy);
      rctx.arc(cx, cy, R, a1, a2);
      rctx.closePath();

      if (showHeatmap && ray.requiredTowerHeight !== undefined) {
        // Heatmap coloring based on required tower height
        const norm = Math.min(ray.requiredTowerHeight / maxTowerH, 1);
        const color = getTowerHeightColor(norm);
        rctx.fillStyle = color;
      } else {
        // Standard visibility coloring
        if (ray.visible) {
          rctx.fillStyle = 'rgba(78,255,160,0.55)';
        } else {
          rctx.fillStyle = 'rgba(255,92,92,0.50)';
        }
      }
      rctx.fill();
      rctx.strokeStyle = showHeatmap ? 'rgba(0,0,0,0.1)' : (ray.visible ? 'rgba(78,255,160,0.2)' : 'rgba(255,92,92,0.2)');
      rctx.lineWidth = 0.5;
      rctx.stroke();
    });
  }

  /* Terrain overlay */
  if (showTerrain && lastRadialParams) {
    rctx.save();
    const { lat, lng } = lastRadialParams;
    const terrainSamples = 72; // samples around circle
    const radialSteps = 50; // distance steps
    
    for (let a = 0; a < terrainSamples; a++) {
      const bearing = (a / terrainSamples) * 360;
      const angleCentre = (bearing - 90) * DEG2RAD;
      
      for (let d = 1; d <= radialSteps; d++) {
        const distKm = (d / radialSteps) * radius;
        const pos = destPoint(lat, lng, bearing, distKm);
        const elev = getElevation(pos.lat, pos.lng);
        
        if (elev !== null) {
          // Simple elevation-based coloring
          const norm = Math.max(0, Math.min(1, elev / 2000));
          const alpha = 0.15;
          const color = getElevationColor(norm).replace('rgb', 'rgba').replace(')', `,${alpha})`);
          
          const r = R * (distKm / radius);
          const dr = R / radialSteps;
          
          rctx.beginPath();
          rctx.moveTo(cx, cy);
          rctx.arc(cx, cy, r, angleCentre - Math.PI/terrainSamples, angleCentre + Math.PI/terrainSamples);
          rctx.closePath();
          rctx.fillStyle = color;
          rctx.fill();
        }
      }
    }
    rctx.restore();
  }

  /* observer dot */
  rctx.beginPath();
  rctx.arc(cx, cy, 5, 0, Math.PI*2);
  rctx.fillStyle = '#ffb340';
  rctx.fill();
  rctx.strokeStyle = '#0a0c0f';
  rctx.lineWidth = 2;
  rctx.stroke();

  radCanvas._drawParams = { cx, cy, R, radius };
}

/* ─── RADIAL TOOLTIP ───────────────────────────────────── */
radCanvas.addEventListener('mousemove', e => {
  if (!radCanvas._drawParams || !radialData.length) return;
  const rect = radCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const { cx, cy, R, radius } = radCanvas._drawParams;

  const dx = mx - cx, dy = my - cy;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist > R || dist < 2) { radTooltip.classList.remove('visible'); return; }

  // bearing from centre: atan2, where 0=North (up = -y)
  let bearing = Math.atan2(dx, -dy) * RAD2DEG;
  if (bearing < 0) bearing += 360;

  // find closest ray
  let closest = null, bestDiff = 999;
  radialData.forEach(r => {
    let diff = Math.abs(r.bearing - bearing);
    if (diff > 180) diff = 360 - diff;
    if (diff < bestDiff) { bestDiff = diff; closest = r; }
  });
  if (!closest) { radTooltip.classList.remove('visible'); return; }

  document.getElementById('rttBearing').textContent = closest.bearing.toFixed(1) + '°';
  document.getElementById('rttDist').textContent    = (closest.visible ? ' · Clear' : ' · Blocked') + ' @ ' + closest.visibleDist.toFixed(2) + ' km';
  radTooltip.style.left = (mx + 14) + 'px';
  radTooltip.style.top  = (my - 20) + 'px';
  radTooltip.classList.add('visible');
});
radCanvas.addEventListener('mouseleave', () => radTooltip.classList.remove('visible'));

/* ─── RADIAL TABLE ─────────────────────────────────────── */
function populateRadialTable() {
  const tbody = document.getElementById('radialTableBody');
  tbody.innerHTML = '';
  radialData.forEach(r => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${r.bearing.toFixed(1)}°</td>
      <td class="${r.visible ? 'vis' : 'blk'}">${r.visible ? 'Visible' : 'Blocked'}</td>
      <td>${r.visibleDist.toFixed(2)} km</td>
      <td>${r.blockElev !== null ? Math.round(r.blockElev)+' m' : '—'}</td>`;
    tbody.appendChild(tr);
  });
}

/* ═══════════════════════════════════════════════════════════
   EXPORTS
   ═══════════════════════════════════════════════════════════ */
document.getElementById('btnExportCSV').addEventListener('click', () => {
  let csv = 'distance_km,elevation_m\n';
  profileData.forEach(p => { csv += `${p.dist.toFixed(4)},${p.elev !== null ? p.elev.toFixed(2) : ''}\n`; });
  downloadText('profile.csv', csv);
});
document.getElementById('btnExportPNG').addEventListener('click', () => {
  const a = document.createElement('a'); a.download = 'profile.png'; a.href = canvas.toDataURL(); a.click();
});
document.getElementById('btnExportRadialPNG').addEventListener('click', () => {
  const a = document.createElement('a'); a.download = 'radial_los.png'; a.href = radCanvas.toDataURL(); a.click();
});
document.getElementById('btnExportRadialCSV').addEventListener('click', () => {
  let csv = 'bearing_deg,visible,visible_dist_km,block_elev_m,block_dist_km\n';
  radialData.forEach(r => {
    csv += `${r.bearing.toFixed(1)},${r.visible},${r.visibleDist.toFixed(3)},${r.blockElev !== null ? r.blockElev.toFixed(1) : ''},${r.blockDist !== null ? r.blockDist.toFixed(3) : ''}\n`;
  });
  downloadText('radial_los.csv', csv);
});

function downloadText(name, text) {
  const blob = new Blob([text], { type: 'text/csv' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ═══════════════════════════════════════════════════════════
   CLEAR
   ═══════════════════════════════════════════════════════════ */
btnClear.addEventListener('click', () => {
  Object.keys(tiles).forEach(k => delete tiles[k]);
  renderTileTags();
  profileData = []; radialData = [];
  profilePanel.classList.remove('visible');
  radialPanel.classList.remove('visible');
  terrainMapPanel.classList.remove('visible');
  ['startLat','startLng','endLat','endLng','radLat','radLng','radRadius'].forEach(id => {
    const el = document.getElementById(id); if(el) el.value = '';
  });
  setStatus('', false);
  updateBtn();
});

// Add listener for heatmap checkbox - needs to regenerate data
document.getElementById('showRadialHeatmap')?.addEventListener('change', () => {
  if (radialData.length > 0) {
    // Need to regenerate with heatmap data
    const lat = parseFloat(document.getElementById('radLat').value);
    const lng = parseFloat(document.getElementById('radLng').value);
    if (!isNaN(lat) && !isNaN(lng)) {
      generateRadial();
    }
  }
});

// Add listener for terrain overlay - just redraw
document.getElementById('showRadialTerrain')?.addEventListener('change', () => {
  if (radialData.length > 0 && lastRadialParams) {
    drawRadial(lastRadialParams.radius);
  }
});

/* ═══════════════════════════════════════════════════════════
   UTILS
   ═══════════════════════════════════════════════════════════ */
function setStatus(msg, isErr) {
  statusMsg.textContent = msg;
  statusMsg.className = 'status-msg' + (isErr ? ' err' : (msg ? ' ok' : ''));
}
function updateBtn() { btnGen.disabled = Object.keys(tiles).length === 0; }
function niceStep(raw) {
  const mag  = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw / mag;
  if (norm < 1.5) return mag;
  if (norm < 3.5) return 2*mag;
  if (norm < 7.5) return 5*mag;
  return 10*mag;
}

window.addEventListener('resize', () => {
  if (currentMode === 'ab' && profileData.length) drawProfile(cachedLOS);
});

// Initialize IndexedDB and auto-load tiles after everything is initialized
initDB().then(() => {
  console.log('IndexedDB initialized');
  loadTilesFromStorage();
}).catch(e => {
  console.error('Failed to initialize database:', e);
  setStatus('Failed to initialize storage: ' + e.message, true);
});

}); // End DOMContentLoaded
</script>
</body>
</html>
