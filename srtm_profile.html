<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SRTM Terrain Profile</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #0a0c0f;
    --bg-panel: #111418;
    --bg-input: #161a22;
    --border: #2a3040;
    --border-focus: #4e9fff;
    --text: #c8d0dc;
    --text-dim: #606878;
    --accent: #4e9fff;
    --accent-warm: #ffb340;
    --accent-green: #4effa0;
    --danger: #ff5c5c;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'IBM Plex Mono', monospace;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* â”€â”€â”€ Header â”€â”€â”€ */
  header {
    border-bottom: 1px solid var(--border);
    padding: 16px 24px;
    background: var(--bg-panel);
    flex-shrink: 0;
  }
  .header-inner { display: flex; align-items: center; gap: 24px; }
  h1 { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 1.3rem; letter-spacing: -0.02em; color: #fff; }
  h1 span { color: var(--accent); }
  .header-sub { font-size: 0.68rem; color: var(--text-dim); letter-spacing: 0.08em; text-transform: uppercase; margin-left: auto; }

  /* â”€â”€â”€ Main Layout â”€â”€â”€ */
  .main-layout {
    display: flex;
    flex: 1;
    overflow: hidden;
    position: relative;
  }
  
  .terrain-map-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--bg);
    position: relative;
  }
  
  .right-panels {
    width: 420px;
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    overflow-y: auto;
  }
  
  .elevation-profile-section {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 420px;
    height: 380px;
    background: var(--bg-panel);
    border-top: 2px solid var(--border);
    border-right: 2px solid var(--border);
    display: none;
    flex-direction: column;
    z-index: 10;
  }
  
  .elevation-profile-section.visible { display: flex; }
  
  .profile-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px 24px;
    min-height: 0;
  }
  
  .profile-options-section {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 420px;
    height: 280px;
    background: var(--bg-panel);
    border-top: 2px solid var(--border);
    border-left: 1px solid var(--border);
    display: none;
    flex-direction: column;
    z-index: 10;
    overflow-y: auto;
  }
  
  .profile-options-section.visible { display: flex; }
  
  .input-data-section {
    background: var(--bg-panel);
    display: flex;
    flex-direction: column;
  }

  /* â”€â”€â”€ Section Headers â”€â”€â”€ */
  .section-header {
    padding: 12px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 12px;
    flex-shrink: 0;
  }
  
  .import-section {
    border-bottom: 1px solid var(--border);
    background: var(--bg-panel);
  }
  
  .import-toggle-btn {
    width: 100%;
    background: var(--bg-input);
    border: none;
    border-bottom: 1px solid var(--border);
    color: var(--text);
    padding: 10px 24px;
    font-family: inherit;
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.2s;
  }
  
  .import-toggle-btn:hover { background: var(--bg-panel); }
  .import-toggle-btn .arrow { transition: transform 0.2s; }
  .import-toggle-btn.open .arrow { transform: rotate(90deg); }
  
  .import-content {
    display: none;
    padding: 12px 24px;
  }
  
  .import-content.open { display: block; }
  .section-title {
    font-size: 0.68rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--accent);
    font-weight: 500;
  }
  .section-title::before {
    content: '';
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 6px var(--accent);
    margin-right: 8px;
  }

  /* â”€â”€â”€ Tabs â”€â”€â”€ */
  .tab-toggle {
    display: flex;
    gap: 4px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px;
    width: fit-content;
    margin-bottom: 16px;
  }
  .tab-btn {
    font-family: inherit;
    font-size: 0.72rem;
    letter-spacing: 0.06em;
    padding: 6px 14px;
    border: none;
    border-radius: 6px;
    background: transparent;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s;
  }
  .tab-btn:hover { background: rgba(78,159,255,0.1); color: var(--accent); }
  .tab-btn.active { background: var(--accent); color: #0a0c0f; font-weight: 500; }
  
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* â”€â”€â”€ Inputs â”€â”€â”€ */
  .input-wrap label { display: block; font-size: 0.62rem; color: var(--text-dim); margin-bottom: 3px; letter-spacing: 0.06em; }
  .input-wrap input, .input-wrap select {
    width: 100%;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: #fff;
    font-family: inherit;
    font-size: 0.82rem;
    padding: 8px 10px;
    transition: border-color 0.2s;
    outline: none;
  }
  .input-wrap input:focus, .input-wrap select:focus { border-color: var(--border-focus); }

  /* â”€â”€â”€ Buttons â”€â”€â”€ */
  .btn {
    font-family: inherit;
    font-size: 0.72rem;
    letter-spacing: 0.1em;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }
  .btn-primary {
    background: var(--accent);
    color: #0a0c0f;
    font-weight: 500;
  }
  .btn-primary:hover { background: #6eb0ff; transform: translateY(-1px); }
  .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
  .btn-secondary {
    background: var(--bg-input);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }

  /* â”€â”€â”€ Dropzone â”€â”€â”€ */
  .dropzone {
    border: 2px dashed var(--border);
    border-radius: 8px;
    padding: 16px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    background: var(--bg-input);
    font-size: 0.75rem;
  }
  .dropzone:hover, .dropzone.dragover { border-color: var(--accent); background: rgba(78,159,255,0.04); }
  .dropzone input { display: none; }
  .dropzone em { color: var(--accent); font-style: normal; }

  /* â”€â”€â”€ Tile List â”€â”€â”€ */
  .tile-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }
  .tile-tag {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 4px 8px;
    font-size: 0.7rem;
  }
  .tag-name { color: var(--accent); font-weight: 500; }
  .tag-res { color: var(--text-dim); font-size: 0.65rem; }
  .tag-remove {
    color: var(--danger);
    cursor: pointer;
    margin-left: 4px;
    font-size: 0.9rem;
  }
  .tag-remove:hover { color: #ff8c8c; }

  /* â”€â”€â”€ Canvas â”€â”€â”€ */
  .canvas-wrap {
    position: relative;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }
  canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
  }
  #profileCanvas {
    width: 100% !important;
    height: 100% !important;
  }
  #terrainMapCanvas { cursor: crosshair; }
  #terrainMapCanvas.panning { cursor: grabbing; }

  /* â”€â”€â”€ Map Controls â”€â”€â”€ */
  .minimap {
    position: absolute;
    bottom: 12px;
    right: 12px;
    width: 120px;
    height: 120px;
    border: 2px solid var(--border);
    border-radius: 6px;
    background: rgba(10,12,15,0.8);
    cursor: pointer;
  }
  .zoom-indicator {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(10,12,15,0.9);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 0.72rem;
    color: var(--accent);
    font-weight: 500;
  }
  .map-hover-info {
    position: absolute;
    background: rgba(10,12,15,0.95);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 0.7rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .map-hover-info.visible { opacity: 1; }
  .info-label { color: var(--text-dim); margin-right: 6px; }
  .info-value { color: var(--accent); font-weight: 500; }

  /* â”€â”€â”€ Checkbox â”€â”€â”€ */
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .checkbox-group input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .checkbox-group label {
    font-size: 0.75rem;
    cursor: pointer;
    margin: 0;
  }

  /* â”€â”€â”€ Profile Stats â”€â”€â”€ */
  .profile-stats {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .stat {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  .stat-label {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }
  .stat-value {
    font-size: 0.85rem;
    color: var(--accent);
    font-weight: 500;
  }

  /* â”€â”€â”€ Profile Options â”€â”€â”€ */
  .profile-options {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 12px;
  }
  .option-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .option-group label {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
  }
  .option-group input {
    width: 80px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: #fff;
    font-size: 0.78rem;
    padding: 4px 8px;
    text-align: center;
  }

  /* â”€â”€â”€ Tooltip â”€â”€â”€ */
  .tooltip {
    position: absolute;
    background: rgba(10,12,15,0.95);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 0.7rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    white-space: nowrap;
  }
  .tooltip.visible { opacity: 1; }
  .tt-elev { color: var(--accent); font-weight: 500; }
  .tt-dist { color: var(--text-dim); }

  /* â”€â”€â”€ Status Message â”€â”€â”€ */
  .status-msg {
    font-size: 0.72rem;
    padding: 8px 12px;
    border-radius: 6px;
    background: var(--bg-input);
    border: 1px solid var(--border);
  }
  .status-msg.error {
    background: rgba(255,92,92,0.1);
    border-color: var(--danger);
    color: var(--danger);
  }

  /* â”€â”€â”€ Info Text â”€â”€â”€ */
  .info-text {
    font-size: 0.7rem;
    color: var(--text-dim);
    font-style: italic;
    padding: 8px 0;
  }

  /* â”€â”€â”€ Map Info Footer â”€â”€â”€ */
  .map-info {
    padding: 8px 24px;
    font-size: 0.68rem;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
  }
</style>
</head>
<body>

<header>
  <div class="header-inner">
    <h1>SRTM <span>Terrain Profile</span></h1>
    <div class="header-sub">elevation Â· line of sight</div>
  </div>
</header>

<div class="main-layout">
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TERRAIN MAP SECTION (Full screen with right panel)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="terrain-map-section">
    <div class="import-section">
      <button class="import-toggle-btn" id="importToggle">
        <span class="arrow">â–¶</span>
        <span>Import HGT Tiles</span>
      </button>
      <div class="import-content" id="importContent">
        <div class="dropzone" id="dropzone" style="margin-bottom: 12px;">
          <input type="file" id="fileInput" accept=".hgt" multiple />
          <span>Drop <em>.hgt</em> files or <em>click</em></span>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
          <button class="btn btn-secondary" id="btnSaveTiles">Save to Storage</button>
          <button class="btn btn-secondary" id="btnLoadTiles">Load from Storage</button>
          <a href="https://viewfinderpanoramas.org/Coverage%20map%20viewfinderpanoramas_org3.htm" target="_blank" class="btn btn-secondary" style="text-decoration: none; display: inline-flex; align-items: center; justify-content: center;">Download HGT</a>
        </div>
        <div class="tile-list" id="tileList"></div>
      </div>
    </div>
    <div class="canvas-wrap" style="flex: 1;">
      <canvas id="terrainMapCanvas"></canvas>
      <canvas class="minimap" id="minimapCanvas"></canvas>
      <div class="zoom-indicator" id="zoomIndicator">1.0x</div>
      <div class="map-hover-info" id="mapHoverInfo">
        <div><span class="info-label">Lat:</span><span class="info-value" id="hoverLat">â€”</span></div>
        <div><span class="info-label">Lng:</span><span class="info-value" id="hoverLng">â€”</span></div>
        <div><span class="info-label">Elev:</span><span class="info-value" id="hoverElev">â€”</span></div>
      </div>
      <button class="btn btn-secondary" id="btnResetZoom" style="position: absolute; top: 12px; left: 12px; z-index: 5;">Reset Zoom</button>
    </div>
  </div>
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ELEVATION PROFILE SECTION (Bottom Panel - Full Width)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="elevation-profile-section" id="profilePanel">
    <div class="section-header">
      <span class="section-title">Elevation Profile</span>
      <div class="profile-stats" style="display: flex; gap: 20px; margin-left: auto; font-size: 0.7rem;">
        <div class="stat"><span class="stat-label">Distance:</span> <span class="stat-value" id="statDist">â€”</span></div>
        <div class="stat"><span class="stat-label">Max:</span> <span class="stat-value" id="statMax">â€”</span></div>
        <div class="stat"><span class="stat-label">Min:</span> <span class="stat-value" id="statMin">â€”</span></div>
        <div class="stat"><span class="stat-label">Start:</span> <span class="stat-value" id="statStart">â€”</span></div>
        <div class="stat"><span class="stat-label">End:</span> <span class="stat-value" id="statEnd">â€”</span></div>
        <div class="stat"><span class="stat-label">LOS:</span> <span class="stat-value" id="statLOS">â€”</span></div>
      </div>
    </div>
    <div class="profile-container">
      <div class="canvas-wrap" style="flex: 1; min-height: 0;">
        <canvas id="profileCanvas"></canvas>
        <div class="tooltip" id="tooltip">
          <span class="tt-elev" id="ttElev">0 m</span>
          <span class="tt-dist" id="ttDist"> Â· 0 km</span>
        </div>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       PROFILE OPTIONS PANEL (Bottom Right)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="profile-options-section" id="profileOptionsPanel">
    <div class="section-header">
      <span class="section-title">Profile Options</span>
    </div>
    <div style="padding: 16px 24px; display: flex; flex-direction: column; gap: 14px;">
      <div class="option-group">
        <label>Observer Tower (m)</label>
        <input type="number" id="startTowerHeight" value="10" min="0" step="1">
      </div>
      <div class="option-group">
        <label>Remote Tower (m)</label>
        <input type="number" id="endTowerHeight" value="10" min="0" step="1">
      </div>
      <div class="option-group">
        <label>Tree Height (m)</label>
        <input type="number" id="treeHeight" value="5" min="0" step="0.5">
      </div>
      <div style="font-size: 0.65rem; color: var(--text-dim); letter-spacing: 0.08em; margin-top: 8px; text-transform: uppercase;">Display Options</div>
      <div class="checkbox-group">
        <input type="checkbox" id="showLOS" checked>
        <label for="showLOS">Line of Sight</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showUserTowers">
        <label for="showUserTowers">Manual Towers</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showMinTowers">
        <label for="showMinTowers">Min Tower Heights</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showOptimalTowers">
        <label for="showOptimalTowers">Optimal Towers</label>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       RIGHT PANELS (Input Data)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="right-panels">
    <div class="input-data-section">
      <div class="section-header">
        <span class="section-title">Input Data</span>
      </div>
    <div style="padding: 16px 24px;">
      
      <!-- Tabs -->
      <div class="tab-toggle">
        <button class="tab-btn active" data-tab="observer">Observer</button>
        <button class="tab-btn" data-tab="radial">Radial LOS</button>
        <button class="tab-btn" data-tab="ab">Aâ†’B Profile</button>
      </div>
      
      <!-- Observer Tab -->
      <div class="tab-content active" id="tab-observer">
        <div style="display: flex; gap: 12px; margin-bottom: 14px;">
          <div class="input-wrap" style="flex: 1;">
            <label>Latitude</label>
            <input type="text" id="obsLat" placeholder="e.g. -42.8826" />
          </div>
          <div class="input-wrap" style="flex: 1;">
            <label>Longitude</label>
            <input type="text" id="obsLng" placeholder="e.g. 147.3257" />
          </div>
        </div>
        <div class="input-wrap" style="width: 180px; margin-bottom: 14px;">
          <label>Observer tower (m)</label>
          <input type="number" id="obsHeight" value="10" min="0" step="1" />
        </div>
        <div class="info-text">
          ðŸ’¡ Click on terrain map to set observer location
        </div>
      </div>
      
      <!-- Radial LOS Tab -->
      <div class="tab-content" id="tab-radial">
        <div style="display: flex; gap: 12px; margin-bottom: 14px; flex-wrap: wrap;">
          <div class="input-wrap" style="width: 140px;">
            <label>Radius (km)</label>
            <input type="text" id="radRadius" placeholder="e.g. 10" />
          </div>
          <div class="input-wrap" style="width: 140px;">
            <label>Angular res. (Â°)</label>
            <select id="radAngRes">
              <option value="0.5">0.5Â° (720)</option>
              <option value="1" selected>1Â° (360)</option>
              <option value="2">2Â° (180)</option>
              <option value="5">5Â° (72)</option>
            </select>
          </div>
        </div>
        <button class="btn btn-primary" id="btnGenerateRadial">Generate Radial LOS</button>
        <div class="info-text">
          ðŸ’¡ Hover over sight lines to see profile
        </div>
      </div>
      
      <!-- Aâ†’B Profile Tab -->
      <div class="tab-content" id="tab-ab">
        <div style="margin-bottom: 6px; font-size: 0.68rem; color: var(--text-dim); letter-spacing: 0.06em;">
          â–¸ TARGET POINT
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 14px;">
          <div class="input-wrap">
            <label>Latitude</label>
            <input type="text" id="endLat" placeholder="e.g. -42.9826" />
          </div>
          <div class="input-wrap">
            <label>Longitude</label>
            <input type="text" id="endLng" placeholder="e.g. 147.4257" />
          </div>
        </div>
        <div class="input-wrap" style="width: 140px; margin-bottom: 14px;">
          <label>Samples</label>
          <select id="sampleCount">
            <option value="500">500</option>
            <option value="1000" selected>1 000</option>
            <option value="2000">2 000</option>
            <option value="5000">5 000</option>
          </select>
        </div>
        <button class="btn btn-primary" id="btnGenerateAB">Generate Profile</button>
      </div>
      
      <div class="status-msg" id="statusMsg" style="margin-top: 14px; display: none;"></div>
    </div>
  </div>
  
  </div><!-- End right-panels -->
  
</div><!-- End main-layout -->

<script>
document.addEventListener('DOMContentLoaded', async function() {
// Version: 2026-02-03-14:30 - Force cache refresh
// Wrap everything in DOMContentLoaded to ensure DOM is ready

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const tiles = {};
let profileData  = [];
let radialData   = [];
let cachedLOS    = null;
let filesLoading = 0;
let observerLocation = null; // {lat, lng}
let targetLocation = null;   // {lat, lng} for Aâ†’B
let currentBearing = null;   // bearing being hovered
let selectedBearing = null;  // bearing selected by click

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INDEXEDDB HELPERS (for large HGT files)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
let db = null;

function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('SRTMDatabase', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('tiles')) {
        db.createObjectStore('tiles', { keyPath: 'key' });
      }
    };
  });
}

function saveTilesToStorage() {
  if (!db) {
    console.error('Database not initialized');
    return;
  }
  
  try {
    const transaction = db.transaction(['tiles'], 'readwrite');
    const store = transaction.objectStore('tiles');
    
    store.clear();
    
    Object.keys(tiles).forEach(key => {
      store.put({
        key: key,
        data: Array.from(tiles[key].data),
        size: tiles[key].size
      });
    });
    
    transaction.oncomplete = () => {
      setStatus(`Saved ${Object.keys(tiles).length} tiles to browser storage`, false);
    };
    
    transaction.onerror = () => {
      setStatus('Error saving tiles: ' + transaction.error, true);
    };
  } catch (e) {
    setStatus('Error saving tiles: ' + e.message, true);
  }
}

function loadTilesFromStorage() {
  if (!db) {
    console.error('Database not initialized');
    return;
  }
  
  try {
    const transaction = db.transaction(['tiles'], 'readonly');
    const store = transaction.objectStore('tiles');
    const request = store.getAll();
    
    request.onsuccess = () => {
      const savedTiles = request.result;
      if (savedTiles.length === 0) {
        setStatus('No saved tiles found', false);
        return;
      }
      
      Object.keys(tiles).forEach(k => delete tiles[k]);
      savedTiles.forEach(tile => {
        tiles[tile.key] = {
          data: new Int16Array(tile.data),
          size: tile.size
        };
      });
      
      renderTileTags();
      
      mapZoom = 1;
      mapOffsetX = 0;
      mapOffsetY = 0;
      
      setTimeout(() => {
        drawTerrainMap();
      }, 50);
      
      setStatus(`Loaded ${Object.keys(tiles).length} tiles from browser storage`, false);
    };
    
    request.onerror = () => {
      setStatus('Error loading tiles: ' + request.error, true);
    };
  } catch (e) {
    setStatus('Error loading tiles: ' + e.message, true);
  }
}

function saveInputsToStorage() {
  try {
    const inputs = {
      obsLat: document.getElementById('obsLat')?.value || '',
      obsLng: document.getElementById('obsLng')?.value || '',
      obsHeight: document.getElementById('obsHeight')?.value || '10',
      endLat: document.getElementById('endLat')?.value || '',
      endLng: document.getElementById('endLng')?.value || '',
      radRadius: document.getElementById('radRadius')?.value || '',
      startTowerHeight: document.getElementById('startTowerHeight')?.value || '10',
      endTowerHeight: document.getElementById('endTowerHeight')?.value || '10',
      treeHeight: document.getElementById('treeHeight')?.value || '5',
      radMaxTowerHeight: document.getElementById('radMaxTowerHeight')?.value || '50'
    };
    localStorage.setItem('srtm_inputs', JSON.stringify(inputs));
  } catch (e) {
    console.error('Error saving inputs:', e);
  }
}

function loadInputsFromStorage() {
  try {
    const saved = localStorage.getItem('srtm_inputs');
    if (!saved) return;
    const inputs = JSON.parse(saved);
    Object.keys(inputs).forEach(key => {
      const el = document.getElementById(key);
      if (el && inputs[key] !== undefined) {
        el.value = inputs[key];
      }
    });
    
    // If observer location was preloaded, set it and display on map
    const obsLat = parseFloat(inputs.obsLat);
    const obsLng = parseFloat(inputs.obsLng);
    if (!isNaN(obsLat) && !isNaN(obsLng)) {
      observerLocation = { lat: obsLat, lng: obsLng };
      drawTerrainMap();
    }
    
    // If target location was preloaded, set it
    const endLat = parseFloat(inputs.endLat);
    const endLng = parseFloat(inputs.endLng);
    if (!isNaN(endLat) && !isNaN(endLng)) {
      targetLocation = { lat: endLat, lng: endLng };
    }
  } catch (e) {
    console.error('Error loading inputs:', e);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DOM ELEMENTS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const dropzone     = document.getElementById('dropzone');
const fileInput    = document.getElementById('fileInput');
const tileList     = document.getElementById('tileList');
const statusMsg    = document.getElementById('statusMsg');

const mapCanvas    = document.getElementById('terrainMapCanvas');
const mctx         = mapCanvas.getContext('2d');
const minimapCanvas= document.getElementById('minimapCanvas');
const miniCtx      = minimapCanvas.getContext('2d');
const mapHoverInfo = document.getElementById('mapHoverInfo');

let mapZoom = 1;
let mapOffsetX = 0;
let mapOffsetY = 0;
let mapIsPanning = false;
let mapLastX = 0;
let mapLastY = 0;

const canvas       = document.getElementById('profileCanvas');
const ctx          = canvas.getContext('2d');
const tooltip      = document.getElementById('tooltip');

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   INITIALIZATION
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
// Initialize database
try {
  await initDB();
  loadTilesFromStorage();
} catch (e) {
  console.error('Failed to initialize database:', e);
  setStatus('Failed to initialize storage: ' + e.message, true);
}

loadInputsFromStorage();

// Auto-save inputs on change
['obsLat','obsLng','obsHeight','endLat','endLng','radRadius','startTowerHeight','endTowerHeight','treeHeight','radMaxTowerHeight'].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', saveInputsToStorage);
});

// Auto-update observer location when manual observer coordinates change
['obsLat', 'obsLng'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      const obsLat = parseFloat(document.getElementById('obsLat').value);
      const obsLng = parseFloat(document.getElementById('obsLng').value);
      
      if (!isNaN(obsLat) && !isNaN(obsLng)) {
        observerLocation = { lat: obsLat, lng: obsLng };
        radialData = []; // Clear radial lines when observer moves
        drawTerrainMap();
      }
    });
  }
});

// Auto-update Aâ†’B profile when target coordinates change
['endLat', 'endLng'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      const obsLat = parseFloat(document.getElementById('obsLat').value);
      const obsLng = parseFloat(document.getElementById('obsLng').value);
      const endLat = parseFloat(document.getElementById('endLat').value);
      const endLng = parseFloat(document.getElementById('endLng').value);
      
      if (!isNaN(obsLat) && !isNaN(obsLng) && !isNaN(endLat) && !isNaN(endLng)) {
        targetLocation = { lat: endLat, lng: endLng };
        drawTerrainMap();
        // Debounce profile generation
        clearTimeout(window._profileUpdateTimer);
        window._profileUpdateTimer = setTimeout(() => {
          generateProfile();
        }, 500);
      }
    });
  }
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   IMPORT TOGGLE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const importToggle = document.getElementById('importToggle');
const importContent = document.getElementById('importContent');

importToggle.addEventListener('click', () => {
  importToggle.classList.toggle('open');
  importContent.classList.toggle('open');
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TAB SWITCHING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getActiveTab() {
  const activeBtn = document.querySelector('.tab-btn.active');
  return activeBtn ? activeBtn.dataset.tab : null;
}

document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.dataset.tab;
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b === btn));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('active', c.id === `tab-${tab}`));
    
    // Show profile panels for Aâ†’B tab
    const profilePanel = document.getElementById('profilePanel');
    const profileOptionsPanel = document.getElementById('profileOptionsPanel');
    if (tab === 'ab' && profileData.length > 0) {
      profilePanel.classList.add('visible');
      profileOptionsPanel.classList.add('visible');
    } else {
      profilePanel.classList.remove('visible');
      profileOptionsPanel.classList.remove('visible');
    }
  });
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DROPZONE / FILE LOADING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
dropzone.addEventListener('click', () => fileInput.click());
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', e => { e.preventDefault(); dropzone.classList.remove('dragover'); });
dropzone.addEventListener('drop', e => { e.preventDefault(); dropzone.classList.remove('dragover'); loadFiles(e.dataTransfer.files); });
fileInput.addEventListener('change', e => loadFiles(e.target.files));

function loadFiles(files) {
  const hgtFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.hgt'));
  if (hgtFiles.length === 0) { setStatus('Please drop .hgt files only.', true); return; }
  
  filesLoading = hgtFiles.length;
  
  hgtFiles.forEach(file => {
    const key = parseTileKey(file.name);
    if (!key) { filesLoading--; return; }
    
    const reader = new FileReader();
    reader.onload = e => {
      const ab   = e.target.result;
      const arr  = new Int16Array(ab);
      const size = Math.sqrt(arr.length);
      if (size !== 1201 && size !== 3601) { 
        setStatus(`Invalid .hgt file: ${file.name}`, true);
        filesLoading--;
        return;
      }
      
      for (let i = 0; i < arr.length; i++) {
        const val = arr[i];
        arr[i] = ((val & 0xff) << 8) | ((val >> 8) & 0xff);
      }
      
      tiles[key] = { data: arr, size };
      renderTileTags();
      
      filesLoading--;
      if (filesLoading === 0) {
        saveTilesToStorage();
        setStatus(`All tiles loaded and saved (${Object.keys(tiles).length} total)`, false);
        drawTerrainMap();
      }
    };
    reader.readAsArrayBuffer(file);
  });
  fileInput.value = '';
}

function parseTileKey(name) {
  const m = name.match(/^([NS])(\d+)([EW])(\d+)\.hgt$/i);
  if (!m) return null;
  const lat = parseInt(m[2]) * (m[1].toUpperCase() === 'N' ? 1 : -1);
  const lng = parseInt(m[4]) * (m[3].toUpperCase() === 'E' ? 1 : -1);
  return tileKeyFromCoord(lat, lng);
}

function tileKeyFromCoord(lat, lng) {
  const floorLat = Math.floor(lat);
  const floorLng = Math.floor(lng);
  const ns = floorLat >= 0 ? 'N' : 'S';
  const ew = floorLng >= 0 ? 'E' : 'W';
  return `${ns}${Math.abs(floorLat).toString().padStart(2,'0')}${ew}${Math.abs(floorLng).toString().padStart(3,'0')}`;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TERRAIN MAP DRAWING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawTerrainMap() {
  const tileKeys = Object.keys(tiles);
  if (tileKeys.length === 0) return;

  let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
  
  tileKeys.forEach(key => {
    const m = key.match(/^([NS])(\d+)([EW])(\d+)$/);
    if (!m) return;
    const lat = parseInt(m[2]) * (m[1] === 'N' ? 1 : -1);
    const lng = parseInt(m[4]) * (m[3] === 'E' ? 1 : -1);
    minLat = Math.min(minLat, lat);
    maxLat = Math.max(maxLat, lat + 1);
    minLng = Math.min(minLng, lng);
    maxLng = Math.max(maxLng, lng + 1);
  });

  const latRange = maxLat - minLat;
  const lngRange = maxLng - minLng;
  
  const dpr = window.devicePixelRatio || 1;
  const rect = mapCanvas.parentElement.getBoundingClientRect();
  const containerW = Math.max(Math.floor(rect.width), 600);
  const containerH = 400;
  
  const dataAspectRatio = lngRange / latRange;
  const containerAspectRatio = containerW / containerH;
  
  let W, H;
  if (dataAspectRatio > containerAspectRatio) {
    W = containerW;
    H = Math.floor(W / dataAspectRatio);
    if (H < containerH * 0.8) {
      H = containerH;
      W = Math.floor(H * dataAspectRatio);
    }
  } else {
    H = containerH;
    W = Math.floor(H * dataAspectRatio);
    if (W < containerW * 0.8) {
      W = containerW;
      H = Math.floor(W / dataAspectRatio);
    }
  }
  
  if (W <= 0 || H <= 0) return;
  
  mapCanvas.width = W * dpr;
  mapCanvas.height = H * dpr;
  mapCanvas.style.width = W + 'px';
  mapCanvas.style.height = H + 'px';
  mctx.scale(dpr, dpr);

  mctx.fillStyle = '#0a0c0f';
  mctx.fillRect(0, 0, W, H);

  // Apply zoom and pan transform
  mctx.save();
  mctx.translate(W/2, H/2);
  mctx.scale(mapZoom, mapZoom);
  mctx.translate(-W/2 + mapOffsetX, -H/2 + mapOffsetY);

  // Calculate visible area for sampling (accounting for zoom/pan)
  // After transform: point (x,y) in data space appears at screen position:
  // screenX = W/2 + (x - W/2 + mapOffsetX) * mapZoom
  // To find what's visible, we need to invert: what (x,y) appears at screen edges?
  // For left edge (screenX = 0): 0 = W/2 + (x - W/2 + mapOffsetX) * mapZoom
  // x = W/2 - mapOffsetX - W/(2*mapZoom)
  const visibleDataMinX = W/2 - mapOffsetX - W/(2*mapZoom);
  const visibleDataMaxX = W/2 - mapOffsetX + W/(2*mapZoom);
  const visibleDataMinY = H/2 - mapOffsetY - H/(2*mapZoom);
  const visibleDataMaxY = H/2 - mapOffsetY + H/(2*mapZoom);
  
  // Convert data space coordinates to lat/lng
  const viewMinLng = minLng + (visibleDataMinX / W) * lngRange;
  const viewMaxLng = minLng + (visibleDataMaxX / W) * lngRange;
  const viewMaxLat = minLat + (1 - visibleDataMinY / H) * latRange;
  const viewMinLat = minLat + (1 - visibleDataMaxY / H) * latRange;
  const viewLatRange = viewMaxLat - viewMinLat;
  const viewLngRange = viewMaxLng - viewMinLng;

  let minElev = Infinity, maxElev = -Infinity;

  // Sample terrain in visible area only - adjust density based on zoom level
  // Lower density when zoomed in (looking at small area), higher when zoomed out (looking at large area)
  const sampleDensity = mapZoom > 3 ? 100 : (mapZoom > 1.5 ? 150 : 200);
  const samples = [];
  
  for (let y = 0; y < sampleDensity; y++) {
    for (let x = 0; x < sampleDensity; x++) {
      const lat = viewMinLat + (viewLatRange * (sampleDensity - y) / sampleDensity);
      const lng = viewMinLng + (viewLngRange * x / sampleDensity);
      const elev = getElevation(lat, lng);
      if (elev !== null) {
        minElev = Math.min(minElev, elev);
        maxElev = Math.max(maxElev, elev);
        // Store canvas coordinates in data space (before transform)
        const canvasX = ((lng - minLng) / lngRange) * W;
        const canvasY = ((maxLat - lat) / latRange) * H;
        samples.push({ x: canvasX, y: canvasY, elev });
      }
    }
  }

  const elevRange = maxElev - minElev || 1;

  // Draw elevation as colored pixels - size based on zoom to fill screen
  const pixelSize = Math.max(Math.ceil(W / sampleDensity) * mapZoom, 1) + 1;
  samples.forEach(s => {
    const norm = (s.elev - minElev) / elevRange;
    const color = elevationColor(norm);
    mctx.fillStyle = color;
    mctx.fillRect(s.x, s.y, pixelSize, pixelSize);
  });

  // Draw grid for tile boundaries
  mctx.strokeStyle = 'rgba(78,159,255,0.3)';
  mctx.lineWidth = 1;
  for (let lat = Math.ceil(minLat); lat <= maxLat; lat++) {
    const py = H * (1 - (lat - minLat) / latRange);
    mctx.beginPath();
    mctx.moveTo(0, py);
    mctx.lineTo(W, py);
    mctx.stroke();
  }
  for (let lng = Math.ceil(minLng); lng <= maxLng; lng++) {
    const px = W * (lng - minLng) / lngRange;
    mctx.beginPath();
    mctx.moveTo(px, 0);
    mctx.lineTo(px, H);
    mctx.stroke();
  }

  // Helper function to convert lat/lng to canvas coordinates (data space)
  const toCanvasX = (lng) => W * (lng - minLng) / lngRange;
  const toCanvasY = (lat) => H * (1 - (lat - minLat) / latRange);

  // Draw radial sight lines if available
  if (radialData && radialData.length > 0 && observerLocation) {
    const cx = toCanvasX(observerLocation.lng);
    const cy = toCanvasY(observerLocation.lat);
    
    mctx.save();
    mctx.lineWidth = 2;
    
    radialData.forEach(ray => {
      mctx.strokeStyle = ray.visible ? 'rgba(78,255,160,0.6)' : 'rgba(255,92,92,0.6)';
      
      const endPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, ray.visibleDist);
      const ex = toCanvasX(endPoint.lng);
      const ey = toCanvasY(endPoint.lat);
      
      mctx.beginPath();
      mctx.moveTo(cx, cy);
      mctx.lineTo(ex, ey);
      mctx.stroke();
      
      mctx.beginPath();
      mctx.arc(ex, ey, 3, 0, Math.PI*2);
      mctx.fillStyle = ray.visible ? 'rgba(78,255,160,0.8)' : 'rgba(255,92,92,0.8)';
      mctx.fill();
    });
    mctx.restore();
  }

  // Draw Aâ†’B line if target location exists
  if (observerLocation && targetLocation) {
    const x1 = toCanvasX(observerLocation.lng);
    const y1 = toCanvasY(observerLocation.lat);
    const x2 = toCanvasX(targetLocation.lng);
    const y2 = toCanvasY(targetLocation.lat);
    
    mctx.strokeStyle = '#4e9fff';
    mctx.lineWidth = 3;
    mctx.setLineDash([8, 4]);
    mctx.beginPath();
    mctx.moveTo(x1, y1);
    mctx.lineTo(x2, y2);
    mctx.stroke();
    mctx.setLineDash([]);
    
    // Draw target marker
    mctx.beginPath();
    mctx.arc(x2, y2, 6, 0, Math.PI*2);
    mctx.fillStyle = '#4e9fff';
    mctx.fill();
    mctx.strokeStyle = '#0a0c0f';
    mctx.lineWidth = 2;
    mctx.stroke();
  }

  // Draw observer marker if set
  if (observerLocation) {
    const ox = toCanvasX(observerLocation.lng);
    const oy = toCanvasY(observerLocation.lat);
    
    mctx.beginPath();
    mctx.arc(ox, oy, 8, 0, Math.PI*2);
    mctx.fillStyle = '#4effa0';
    mctx.fill();
    mctx.strokeStyle = '#0a0c0f';
    mctx.lineWidth = 2;
    mctx.stroke();
  }

  mctx.restore();

  mapCanvas._mapParams = { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom: mapZoom, offsetX: mapOffsetX, offsetY: mapOffsetY };

  document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';

  drawMinimap(minLat, maxLat, minLng, maxLng, W, H);
}

function elevationColor(norm) {
  if (norm < 0.25) {
    const t = norm / 0.25;
    return `rgb(${Math.round(30 + t * 70)}, ${Math.round(60 + t * 90)}, ${Math.round(90 + t * 60)})`;
  } else if (norm < 0.5) {
    const t = (norm - 0.25) / 0.25;
    return `rgb(${Math.round(100 + t * 55)}, ${Math.round(150 + t * 55)}, ${Math.round(150 - t * 50)})`;
  } else if (norm < 0.75) {
    const t = (norm - 0.5) / 0.25;
    return `rgb(${Math.round(155 + t * 70)}, ${Math.round(205 - t * 55)}, ${Math.round(100 - t * 50)})`;
  } else {
    const t = (norm - 0.75) / 0.25;
    return `rgb(${Math.round(225 + t * 30)}, ${Math.round(150 - t * 50)}, ${Math.round(50 - t * 20)})`;
  }
}

function drawMinimap(minLat, maxLat, minLng, maxLng, mainW, mainH) {
  const size = 120;
  minimapCanvas.width = size;
  minimapCanvas.height = size;
  
  miniCtx.fillStyle = '#0a0c0f';
  miniCtx.fillRect(0, 0, size, size);
  
  // Draw simplified terrain
  const latRange = maxLat - minLat;
  const lngRange = maxLng - minLng;
  
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const lng = minLng + (x / size) * lngRange;
      const lat = minLat + (1 - y / size) * latRange;
      const elev = getElevation(lat, lng);
      if (elev !== null) {
        const norm = (elev + 100) / 3000;
        const c = Math.round(norm * 180 + 40);
        miniCtx.fillStyle = `rgb(${c},${c},${c})`;
        miniCtx.fillRect(x, y, 1, 1);
      }
    }
  }
  
  // Draw viewport rectangle
  const zoom = mapZoom;
  const vw = size / zoom;
  const vh = size / zoom;
  const vx = size/2 - vw/2 - (mapOffsetX / mainW) * size * zoom;
  const vy = size/2 - vh/2 - (mapOffsetY / mainH) * size * zoom;
  
  miniCtx.strokeStyle = '#4e9fff';
  miniCtx.lineWidth = 2;
  miniCtx.strokeRect(vx, vy, vw, vh);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MAP INTERACTIONS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
// Click to set observer or target based on active tab
mapCanvas.addEventListener('click', e => {
  if (!mapCanvas._mapParams) return;
  
  const activeTab = getActiveTab();
  
  const rect = mapCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  
  const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY } = mapCanvas._mapParams;
  
  // Inverse transform to get data space coordinates
  const tx = (mx - W/2) / zoom - offsetX + W/2;
  const ty = (my - H/2) / zoom - offsetY + H/2;
  
  if (tx >= 0 && tx <= W && ty >= 0 && ty <= H) {
    const lng = minLng + (tx / W) * lngRange;
    const lat = minLat + (1 - ty / H) * latRange;
    
    if (activeTab === 'observer') {
      // Set observer location
      observerLocation = { lat, lng };
      document.getElementById('obsLat').value = lat.toFixed(5);
      document.getElementById('obsLng').value = lng.toFixed(5);
      radialData = []; // Clear radial lines when observer moves
      selectedBearing = null; // Clear selection when observer moves
      
      setStatus('Observer location set to ' + lat.toFixed(5) + ', ' + lng.toFixed(5), false);
      drawTerrainMap();
    } else if (activeTab === 'ab') {
      // Check if clicking on a radial line
      if (radialData && radialData.length > 0 && observerLocation) {
        const hoveredRay = findHoveredRay(mx, my, minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY);
        
        if (hoveredRay) {
          // Clicked on a radial line - update target to that line's endpoint
          selectedBearing = hoveredRay.bearing; // Remember this selection
          const endPoint = destPoint(observerLocation.lat, observerLocation.lng, hoveredRay.bearing, hoveredRay.visibleDist);
          targetLocation = { lat: endPoint.lat, lng: endPoint.lng };
          document.getElementById('endLat').value = endPoint.lat.toFixed(5);
          document.getElementById('endLng').value = endPoint.lng.toFixed(5);
          
          // Use cached profile data
          if (hoveredRay.profileData && hoveredRay.losResult) {
            profileData = hoveredRay.profileData;
            cachedLOS = hoveredRay.losResult;
            
            const radObserverHeight = parseFloat(document.getElementById('obsHeight')?.value || 0);
            document.getElementById('startTowerHeight').value = radObserverHeight;
            document.getElementById('endTowerHeight').value = 0;
            if (radObserverHeight > 0) {
              document.getElementById('showUserTowers').checked = true;
            }
            
            // Show profile panels
            const profilePanel = document.getElementById('profilePanel');
            const profileOptionsPanel = document.getElementById('profileOptionsPanel');
            if (profilePanel && profileOptionsPanel) {
              profilePanel.classList.add('visible');
              profileOptionsPanel.classList.add('visible');
            }
            
            // Update profile display
            const dist = haversine(observerLocation.lat, observerLocation.lng, endPoint.lat, endPoint.lng);
            updateProfileStats(dist, cachedLOS);
            drawProfile(cachedLOS);
          }
          
          setStatus('Selected radial line at bearing ' + hoveredRay.bearing.toFixed(1) + 'Â°', false);
          drawTerrainMap(); // Redraw to show updated blue line
        } else {
          // Not on a radial line - set target to clicked location and generate profile
          selectedBearing = null; // Clear selection
          targetLocation = { lat, lng };
          document.getElementById('endLat').value = lat.toFixed(5);
          document.getElementById('endLng').value = lng.toFixed(5);
          
          setStatus('Target location set to ' + lat.toFixed(5) + ', ' + lng.toFixed(5), false);
          drawTerrainMap(); // Redraw to show updated blue line
          
          // Generate profile for this location
          if (observerLocation) {
            generateProfile();
          }
        }
      } else {
        // No radial lines - set target location and generate profile
        selectedBearing = null; // Clear selection
        targetLocation = { lat, lng };
        document.getElementById('endLat').value = lat.toFixed(5);
        document.getElementById('endLng').value = lng.toFixed(5);
        
        setStatus('Target location set to ' + lat.toFixed(5) + ', ' + lng.toFixed(5), false);
        drawTerrainMap(); // Redraw to show updated blue line
        
        // Generate profile for this location
        if (observerLocation) {
          generateProfile();
        }
      }
    }
  }
});

// Hover to show coordinates
mapCanvas.addEventListener('mousemove', e => {
  if (mapIsPanning || !mapCanvas._mapParams) return;
  
  const rect = mapCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  
  const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY } = mapCanvas._mapParams;
  
  // Inverse transform to get data space coordinates
  const tx = (mx - W/2) / zoom - offsetX + W/2;
  const ty = (my - H/2) / zoom - offsetY + H/2;
  
  if (tx < 0 || tx > W || ty < 0 || ty > H) {
    mapHoverInfo.classList.remove('visible');
    return;
  }
  
  const lng = minLng + (tx / W) * lngRange;
  const lat = minLat + (1 - ty / H) * latRange;
  const elev = getElevation(lat, lng);
  
  if (elev !== null) {
    document.getElementById('hoverLat').textContent = lat.toFixed(5) + 'Â°';
    document.getElementById('hoverLng').textContent = lng.toFixed(5) + 'Â°';
    document.getElementById('hoverElev').textContent = Math.round(elev) + ' m';
    mapHoverInfo.style.left = (mx + 14) + 'px';
    mapHoverInfo.style.top = (my - 60) + 'px';
    mapHoverInfo.classList.add('visible');
    
    // Check if hovering over a radial line (only on Aâ†’B tab)
    const activeTab = getActiveTab();
    if (activeTab === 'ab' && radialData && radialData.length > 0 && observerLocation) {
      const hoveredRay = findHoveredRay(mx, my, minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY);
      
      // Use hovered ray if hovering, otherwise use selected ray
      const rayToShow = hoveredRay || (selectedBearing !== null ? radialData.find(r => r.bearing === selectedBearing) : null);
      const rayBearing = rayToShow ? rayToShow.bearing : null;
      
      if (rayToShow && rayBearing !== currentBearing) {
        currentBearing = rayBearing;
        
        // Calculate endpoint but DON'T update targetLocation (to avoid map redraw)
        const endPoint = destPoint(observerLocation.lat, observerLocation.lng, rayToShow.bearing, rayToShow.visibleDist);
        
        // Update input fields only (don't update targetLocation to avoid triggering map redraw)
        document.getElementById('endLat').value = endPoint.lat.toFixed(5);
        document.getElementById('endLng').value = endPoint.lng.toFixed(5);
        saveInputsToStorage();
        
        // Use cached profile data instead of recalculating
        if (rayToShow.profileData && rayToShow.losResult) {
          profileData = rayToShow.profileData;
          cachedLOS = rayToShow.losResult;
          
          const radObserverHeight = parseFloat(document.getElementById('obsHeight')?.value || 0);
          document.getElementById('startTowerHeight').value = radObserverHeight;
          document.getElementById('endTowerHeight').value = 0;
          // Enable manual towers checkbox if radial observer tower > 0
          if (radObserverHeight > 0) {
            document.getElementById('showUserTowers').checked = true;
          }
          
          // Show profile panels since we have data
          const profilePanel = document.getElementById('profilePanel');
          const profileOptionsPanel = document.getElementById('profileOptionsPanel');
          if (profilePanel && profileOptionsPanel) {
            profilePanel.classList.add('visible');
            profileOptionsPanel.classList.add('visible');
          }
          
          // Update profile display ONLY (no map redraw)
          const dist = haversine(observerLocation.lat, observerLocation.lng, endPoint.lat, endPoint.lng);
          updateProfileStats(dist, cachedLOS);
          drawProfile(cachedLOS);
        }
      }
    } else if (activeTab !== 'ab') {
      // Reset current bearing when not on Aâ†’B tab
      currentBearing = null;
    }
  } else {
    mapHoverInfo.classList.remove('visible');
  }
});

mapCanvas.addEventListener('mouseleave', () => {
  mapHoverInfo.classList.remove('visible');
  currentBearing = null;
});

function findHoveredRay(mx, my, minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY) {
  if (!observerLocation || !radialData || radialData.length === 0) return null;
  
  // Convert lat/lng to canvas data space coordinates (before transformation)
  const toCanvasX = (lng) => W * (lng - minLng) / lngRange;
  const toCanvasY = (lat) => H * (1 - (lat - minLat) / latRange);
  
  const cx = toCanvasX(observerLocation.lng);
  const cy = toCanvasY(observerLocation.lat);
  
  let minDist = 15; // pixel threshold
  let closestRay = null;
  
  radialData.forEach(ray => {
    const endPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, ray.visibleDist);
    const ex = toCanvasX(endPoint.lng);
    const ey = toCanvasY(endPoint.lat);
    
    // Transform canvas coordinates to screen space
    const scx = (cx - W/2) * zoom + W/2 + offsetX * zoom;
    const scy = (cy - H/2) * zoom + H/2 + offsetY * zoom;
    const sex = (ex - W/2) * zoom + W/2 + offsetX * zoom;
    const sey = (ey - H/2) * zoom + H/2 + offsetY * zoom;
    
    const dist = distanceToLineSegment(mx, my, scx, scy, sex, sey);
    if (dist < minDist) {
      minDist = dist;
      closestRay = ray;
    }
  });
  
  return closestRay;
}

// Pan
mapCanvas.addEventListener('mousedown', e => {
  mapIsPanning = true;
  mapLastX = e.clientX;
  mapLastY = e.clientY;
  mapCanvas.classList.add('panning');
});

mapCanvas.addEventListener('mousemove', e => {
  if (!mapIsPanning) return;
  const dx = e.clientX - mapLastX;
  const dy = e.clientY - mapLastY;
  mapOffsetX += dx / mapZoom;
  mapOffsetY += dy / mapZoom;
  mapLastX = e.clientX;
  mapLastY = e.clientY;
  
  // Debounce drawing during pan
  clearTimeout(window._panDrawTimer);
  window._panDrawTimer = setTimeout(() => drawTerrainMap(), 16); // ~60fps
});

mapCanvas.addEventListener('mouseup', () => {
  mapIsPanning = false;
  mapCanvas.classList.remove('panning');
});

mapCanvas.addEventListener('mouseleave', () => {
  mapIsPanning = false;
  mapCanvas.classList.remove('panning');
});

// Zoom
mapCanvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  mapZoom *= zoomFactor;
  mapZoom = Math.max(0.5, Math.min(10, mapZoom));
  document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';
  
  // Debounce drawing during zoom
  clearTimeout(window._zoomDrawTimer);
  window._zoomDrawTimer = setTimeout(() => drawTerrainMap(), 16); // ~60fps
});

// Minimap navigation
minimapCanvas.addEventListener('click', e => {
  const rect = minimapCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  
  if (!mapCanvas._mapParams) return;
  const { W, H } = mapCanvas._mapParams;
  
  const targetX = (x - 0.5) * W;
  const targetY = (y - 0.5) * H;
  
  mapOffsetX = -targetX;
  mapOffsetY = -targetY;
  drawTerrainMap();
});

document.getElementById('btnResetZoom')?.addEventListener('click', () => {
  mapZoom = 1;
  mapOffsetX = 0;
  mapOffsetY = 0;
  drawTerrainMap();
});

document.getElementById('btnSaveTiles')?.addEventListener('click', saveTilesToStorage);
document.getElementById('btnLoadTiles')?.addEventListener('click', loadTilesFromStorage);

function renderTileTags() {
  tileList.innerHTML = '';
  Object.keys(tiles).forEach(key => {
    const t   = tiles[key];
    const tag = document.createElement('div');
    tag.className = 'tile-tag';
    tag.innerHTML = `<span class="tag-name">${key}</span><span class="tag-res">${t.size === 1201 ? '3â€³' : '1â€³'}</span><span class="tag-remove" data-key="${key}">âœ•</span>`;
    tileList.appendChild(tag);
  });
  tileList.querySelectorAll('.tag-remove').forEach(el => {
    el.addEventListener('click', () => { 
      delete tiles[el.dataset.key]; 
      renderTileTags(); 
      drawTerrainMap();
    });
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ELEVATION LOOKUP
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function getElevation(lat, lng) {
  const key = tileKeyFromCoord(lat, lng);
  const tile = tiles[key];
  if (!tile) return null;

  const { data, size } = tile;
  const floorLat = Math.floor(lat);
  const floorLng = Math.floor(lng);

  const rowFrac = (lat - floorLat);
  const colFrac = (lng - floorLng);

  const row = (1 - rowFrac) * (size - 1);
  const col = colFrac * (size - 1);

  const r0 = Math.floor(row), r1 = Math.min(r0 + 1, size - 1);
  const c0 = Math.floor(col), c1 = Math.min(c0 + 1, size - 1);

  const e00 = data[r0 * size + c0];
  const e01 = data[r0 * size + c1];
  const e10 = data[r1 * size + c0];
  const e11 = data[r1 * size + c1];

  if (e00 === -32768 || e01 === -32768 || e10 === -32768 || e11 === -32768) return null;

  const tr = row - r0;
  const tc = col - c0;
  const top = e00 * (1 - tc) + e01 * tc;
  const bot = e10 * (1 - tc) + e11 * tc;
  return top * (1 - tr) + bot * tr;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GEO HELPERS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
const EARTH_R = 6371.0;

function haversine(lat1, lng1, lat2, lng2) {
  const dLat = (lat2 - lat1) * DEG2RAD;
  const dLng = (lng2 - lng1) * DEG2RAD;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*DEG2RAD)*Math.cos(lat2*DEG2RAD)*Math.sin(dLng/2)**2;
  return EARTH_R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function interpolateLine(lat1, lng1, lat2, lng2, t) {
  return { lat: lat1+(lat2-lat1)*t, lng: lng1+(lng2-lng1)*t };
}

function destPoint(lat, lng, bearingDeg, distKm) {
  const lat1 = lat * DEG2RAD;
  const lng1 = lng * DEG2RAD;
  const brng = bearingDeg * DEG2RAD;
  const d    = distKm / EARTH_R;

  const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(brng));
  const lng2 = lng1 + Math.atan2(Math.sin(brng)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
  return { lat: lat2 * RAD2DEG, lng: lng2 * RAD2DEG };
}

function distanceToLineSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const lengthSquared = dx * dx + dy * dy;
  
  if (lengthSquared === 0) {
    const dpx = px - x1;
    const dpy = py - y1;
    return Math.sqrt(dpx * dpx + dpy * dpy);
  }
  
  let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
  t = Math.max(0, Math.min(1, t));
  
  const closestX = x1 + t * dx;
  const closestY = y1 + t * dy;
  
  const dpx = px - closestX;
  const dpy = py - closestY;
  return Math.sqrt(dpx * dpx + dpy * dpy);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LINE OF SIGHT CHECK
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function checkLOS(lat1, lng1, elev1, lat2, lng2, samples, treeH = 0, elev2 = null) {
  const dist = haversine(lat1, lng1, lat2, lng2);
  if (elev2 === null) {
    elev2 = getElevation(lat2, lng2) || 0;
  }
  
  let visible = true;
  let visibleDist = dist;
  let blockElev = null;
  let blockDist = null;
  const blockages = []; // Array of obstruction entry/exit points
  let wasBlocked = false; // Track previous sample state

  for (let i = 1; i < samples; i++) {
    const t = i / samples;
    const pt = interpolateLine(lat1, lng1, lat2, lng2, t);
    const terrainElev = getElevation(pt.lat, pt.lng);
    if (terrainElev === null) continue;
    
    const effectiveElev = terrainElev + treeH;
    const d = dist * t;
    const lineElev = elev1 + (elev2 - elev1) * t;
    
    const isBlocked = effectiveElev > lineElev;
    
    // Detect transitions: entering or exiting obstruction
    if (isBlocked && !wasBlocked) {
      // Entering obstruction
      blockages.push({ dist: d, elev: effectiveElev, type: 'entry' });
      visible = false;
      if (blockElev === null) {
        blockElev = effectiveElev;
        blockDist = d;
        visibleDist = d;
      }
    } else if (!isBlocked && wasBlocked) {
      // Exiting obstruction - mark previous point as exit
      if (blockages.length > 0) {
        const prevT = (i - 1) / samples;
        const prevPt = interpolateLine(lat1, lng1, lat2, lng2, prevT);
        const prevTerrainElev = getElevation(prevPt.lat, prevPt.lng);
        if (prevTerrainElev !== null) {
          blockages.push({ dist: dist * prevT, elev: prevTerrainElev + treeH, type: 'exit' });
        }
      }
    }
    
    wasBlocked = isBlocked;
  }

  return { visible, visibleDist, blockElev, blockDist, blockages };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GENERATE Aâ†’B PROFILE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.getElementById('btnGenerateAB')?.addEventListener('click', generateProfile);

function generateProfile() {
  const sLat = parseFloat(document.getElementById('obsLat').value);
  const sLng = parseFloat(document.getElementById('obsLng').value);
  const eLat = parseFloat(document.getElementById('endLat').value);
  const eLng = parseFloat(document.getElementById('endLng').value);

  if ([sLat, sLng, eLat, eLng].some(isNaN)) { 
    setStatus('Observer and target coordinates are required.', true); 
    return; 
  }

  observerLocation = { lat: sLat, lng: sLng };
  targetLocation = { lat: eLat, lng: eLng };

  const N    = parseInt(document.getElementById('sampleCount').value);
  const dist = haversine(sLat, sLng, eLat, eLng);
  profileData = [];

  for (let i = 0; i <= N; i++) {
    const t    = i / N;
    const pt   = interpolateLine(sLat, sLng, eLat, eLng, t);
    const elev = getElevation(pt.lat, pt.lng);
    const d    = dist * t;
    profileData.push({ dist: d, elev: elev !== null ? elev : null });
  }

  if (profileData.every(p => p.elev === null)) { 
    setStatus('No elevation data â€” check tiles are loaded.', true); 
    return; 
  }

  const startElev = profileData.find(p => p.elev !== null)?.elev ?? 0;
  const endElev = profileData[profileData.length - 1]?.elev ?? 0;
  const obsH = parseFloat(document.getElementById('obsHeight')?.value || 0);
  const treeH = parseFloat(document.getElementById('treeHeight')?.value || 5);
  
  const losResult = checkLOS(sLat, sLng, startElev + obsH, eLat, eLng, N, treeH, endElev);

  setStatus(`Profile generated Â· ${N+1} samples Â· ${dist.toFixed(2)} km`, false);

  cachedLOS = losResult;
  updateProfileStats(dist, losResult);
  drawProfile(losResult);
  drawTerrainMap();
  
  // Show profile panels
  document.getElementById('profilePanel').classList.add('visible');
  document.getElementById('profileOptionsPanel').classList.add('visible');
}

function updateProfileStats(dist, losResult) {
  const validElevs = profileData.filter(p => p.elev !== null).map(p => p.elev);
  const maxElev = Math.max(...validElevs);
  const minElev = Math.min(...validElevs);
  const startElev = profileData.find(p => p.elev !== null)?.elev;
  const endElev = profileData[profileData.length - 1]?.elev;

  document.getElementById('statDist').innerHTML = `${dist.toFixed(2)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">km</span>`;
  document.getElementById('statMax').innerHTML = `${Math.round(maxElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>`;
  document.getElementById('statMin').innerHTML = `${Math.round(minElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>`;
  document.getElementById('statStart').innerHTML = startElev ? `${Math.round(startElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>` : 'â€”';
  document.getElementById('statEnd').innerHTML = endElev ? `${Math.round(endElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>` : 'â€”';
  document.getElementById('statLOS').innerHTML = losResult.visible 
    ? '<span style="color:var(--accent-green)">VISIBLE</span>' 
    : '<span style="color:var(--danger)">BLOCKED</span>';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   HELPER FUNCTIONS FOR PROFILE DRAWING
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function niceStep(raw) {
  const mag  = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw / mag;
  if (norm < 1.5) return mag;
  if (norm < 3.5) return 2*mag;
  if (norm < 7.5) return 5*mag;
  return 10*mag;
}

function calculateOptimalTowerHeights(profileData, treeHeight = 5) {
  // Calculate optimal tower heights at start and end to minimize TOTAL height (start + end)
  const n = profileData.length;
  if (n < 2) return { startHeight: 0, endHeight: 0, totalHeight: 0 };
  
  const startElev = profileData[0].elev || 0;
  const endElev = profileData[n - 1].elev || 0;
  const totalDist = profileData[n - 1].dist;
  
  let minTotalHeight = Infinity;
  let bestStart = 0, bestEnd = 0;
  
  // Binary search / optimization for minimum total height
  // For each possible total height, find if there's a valid split
  for (let totalH = 0; totalH <= 200; totalH += 0.5) {
    // Try different splits of this total height
    for (let startH = 0; startH <= totalH; startH += 0.5) {
      const endH = totalH - startH;
      
      // Check if this combination gives LOS
      const p1Elev = startElev + startH;
      const p2Elev = endElev + endH;
      let clearLOS = true;
      
      for (let i = 1; i < n - 1; i++) {
        if (profileData[i].elev === null) continue;
        
        const dist = profileData[i].dist;
        const terrainElev = profileData[i].elev + treeHeight;
        
        // Height of LOS line at this point
        const t = dist / totalDist;
        const losElev = p1Elev + (p2Elev - p1Elev) * t;
        
        if (terrainElev > losElev) {
          clearLOS = false;
          break;
        }
      }
      
      if (clearLOS) {
        if (totalH < minTotalHeight) {
          minTotalHeight = totalH;
          bestStart = startH;
          bestEnd = endH;
        }
        break; // Found a valid split for this total, no need to try more
      }
    }
    
    // Early exit if we found a solution
    if (minTotalHeight < Infinity) {
      break;
    }
  }
  
  return { startHeight: bestStart, endHeight: bestEnd, totalHeight: minTotalHeight };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DRAW PROFILE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawProfile(los) {
  const dpr  = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const W    = rect.width > 0 ? rect.width : 1060;
  const H    = rect.height > 0 ? rect.height : 320;
  
  // Use full container dimensions
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  ctx.scale(dpr, dpr);

  // Get actual canvas dimensions
  const actualW = W;
  const actualH = H;
  
  const validPoints = profileData.filter(p => p.elev !== null);
  
  const pad = { top: 30, right: 28, bottom: 40, left: 62 };
  const pw  = actualW - pad.left - pad.right;
  const ph  = actualH - pad.top  - pad.bottom;

  // Reuse validPoints from aspect ratio calculation if available, otherwise recalculate
  let maxDist, minElev, maxElev, elevRange;
  if (validPoints.length > 0) {
    maxDist  = profileData[profileData.length-1].dist;
    minElev  = Math.min(...validPoints.map(p => p.elev));
    maxElev  = Math.max(...validPoints.map(p => p.elev));
    elevRange= maxElev - minElev || 1;
  } else {
    const vp = profileData.filter(p => p.elev !== null);
    maxDist  = profileData[profileData.length-1]?.dist || 0;
    minElev  = vp.length > 0 ? Math.min(...vp.map(p => p.elev)) : 0;
    maxElev  = vp.length > 0 ? Math.max(...vp.map(p => p.elev)) : 0;
    elevRange= maxElev - minElev || 1;
  }
  const padElev  = elevRange * 0.06;

  const toX = d => pad.left + (d / maxDist) * pw;
  const toY = e => pad.top  + ph - ((e - minElev + padElev) / (elevRange + padElev*2)) * ph;

  ctx.clearRect(0, 0, actualW, actualH);

  /* grid */
  ctx.save();
  ctx.font = '10px "IBM Plex Mono", monospace';
  ctx.fillStyle = '#606878';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  const elevStep  = niceStep(elevRange / 4);
  const elevStart = Math.floor((minElev - padElev) / elevStep) * elevStep;
  for (let e = elevStart; e <= maxElev + padElev; e += elevStep) {
    const y = toY(e);
    if (y < pad.top || y > actualH-pad.bottom) continue;
    ctx.strokeStyle = (e%(elevStep*2)===0) ? 'rgba(78,159,255,0.15)' : 'rgba(78,159,255,0.07)';
    ctx.lineWidth = 0.7;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(actualW-pad.right, y); ctx.stroke();
    ctx.fillText(Math.round(e)+' m', pad.left-8, y);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  const distStep = niceStep(maxDist / 5);
  for (let d = 0; d <= maxDist; d += distStep) {
    const x = toX(d);
    ctx.strokeStyle = 'rgba(78,159,255,0.07)';
    ctx.lineWidth = 0.7;
    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, actualH-pad.bottom); ctx.stroke();
    ctx.fillStyle = '#606878';
    ctx.fillText(d.toFixed(1)+' km', x, actualH-pad.bottom+6);
  }
  ctx.restore();

  /* filled area */
  const grad = ctx.createLinearGradient(0, pad.top, 0, actualH-pad.bottom);
  grad.addColorStop(0, 'rgba(78,159,255,0.40)');
  grad.addColorStop(1, 'rgba(78,159,255,0.02)');

  ctx.beginPath();
  let started = false;
  profileData.forEach(p => {
    if (p.elev === null) { started = false; return; }
    const x = toX(p.dist), y = toY(p.elev);
    if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
  });
  const lastValid  = [...profileData].reverse().find(p => p.elev !== null);
  const firstValid = profileData.find(p => p.elev !== null);
  if (lastValid && firstValid) {
    ctx.lineTo(toX(lastValid.dist), actualH-pad.bottom);
    ctx.lineTo(toX(firstValid.dist), actualH-pad.bottom);
    ctx.closePath();
  }
  ctx.fillStyle = grad;
  ctx.fill();

  /* terrain stroke */
  ctx.beginPath();
  started = false;
  profileData.forEach(p => {
    if (p.elev === null) { started = false; return; }
    const x = toX(p.dist), y = toY(p.elev);
    if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
  });
  ctx.strokeStyle = '#4e9fff';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.stroke();

  /* â”€â”€â”€ TOWER HEIGHT LINES â”€â”€â”€ */
  const showLOS = document.getElementById('showLOS')?.checked ?? true;
  const showUserTowers = document.getElementById('showUserTowers')?.checked;
  const showMinTowers = document.getElementById('showMinTowers')?.checked;
  const showOptimalTowers = document.getElementById('showOptimalTowers')?.checked;
  const treeHeight = parseFloat(document.getElementById('treeHeight')?.value || 5);
  
  // Draw tree height offset as filled area
  if (treeHeight > 0) {
    ctx.save();
    const treeGrad = ctx.createLinearGradient(0, pad.top, 0, H-pad.bottom);
    treeGrad.addColorStop(0, 'rgba(34,139,34,0.2)');
    treeGrad.addColorStop(1, 'rgba(34,139,34,0.05)');
    
    ctx.beginPath();
    let started = false;
    profileData.forEach(p => {
      if (p.elev === null) { started = false; return; }
      const x = toX(p.dist), y = toY(p.elev + treeHeight);
      if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    // Close the path along terrain
    const reversed = [...profileData].reverse();
    reversed.forEach(p => {
      if (p.elev === null) return;
      const x = toX(p.dist), y = toY(p.elev);
      ctx.lineTo(x,y);
    });
    ctx.closePath();
    ctx.fillStyle = treeGrad;
    ctx.fill();
    
    // Draw tree height line
    ctx.strokeStyle = 'rgba(34,139,34,0.6)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 2]);
    ctx.beginPath();
    started = false;
    profileData.forEach(p => {
      if (p.elev === null) { started = false; return; }
      const x = toX(p.dist), y = toY(p.elev + treeHeight);
      if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.restore();
  }

  // Draw user-defined tower heights
  if (showUserTowers && firstValid && lastValid) {
    const startTowerH = parseFloat(document.getElementById('startTowerHeight')?.value || 10);
    const endTowerH = parseFloat(document.getElementById('endTowerHeight')?.value || 10);
    
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startTowerH);
    const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev + endTowerH);

    ctx.save();
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = '#ffb340';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
    
    // Draw tower verticals
    ctx.save();
    ctx.strokeStyle = '#ffb340';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  // Draw minimum tower heights: line from start tower to end point, and end tower to start point
  if (showMinTowers && firstValid && lastValid) {
    // Calculate height needed at start to see end at ground level (accounting for trees)
    let startHeightNeeded = 0;
    const totalDist = lastValid.dist - firstValid.dist;
    
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeHeight; // Terrain + trees
      
      // Line of sight from start tower (height unknown) to end ground level
      // At point i, the LOS elevation would be: startElev + h + (endElev - (startElev + h)) * progress
      // Where progress = (iDist - firstValid.dist) / totalDist
      // Simplifying: startElev + h * (1 - progress) + endElev * progress
      const progress = (iDist - firstValid.dist) / totalDist;
      
      // We need: iElev <= startElev + h * (1 - progress) + endElev * progress
      // Solving for h: h >= (iElev - startElev - endElev * progress) / (1 - progress)
      if (progress < 1) {
        const requiredH = (iElev - firstValid.elev - lastValid.elev * progress) / (1 - progress);
        startHeightNeeded = Math.max(startHeightNeeded, requiredH);
      }
    }
    startHeightNeeded = Math.max(0, startHeightNeeded);

    // Calculate height needed at end to see start at ground level (accounting for trees)
    let endHeightNeeded = 0;
    
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeHeight; // Terrain + trees
      
      // Line of sight from end tower (height unknown) to start ground level
      // At point i, the LOS elevation would be: endElev + h + (startElev - (endElev + h)) * reverseProgress
      // Where reverseProgress = (lastValid.dist - iDist) / totalDist
      const reverseProgress = (lastValid.dist - iDist) / totalDist;
      
      // We need: iElev <= endElev + h * (1 - reverseProgress) + startElev * reverseProgress
      // Solving for h: h >= (iElev - endElev - startElev * reverseProgress) / (1 - reverseProgress)
      if (reverseProgress < 1) {
        const requiredH = (iElev - lastValid.elev - firstValid.elev * reverseProgress) / (1 - reverseProgress);
        endHeightNeeded = Math.max(endHeightNeeded, requiredH);
      }
    }
    endHeightNeeded = Math.max(0, endHeightNeeded);

    ctx.save();
    
    // Line from start tower to end
    if (startHeightNeeded > 0) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startHeightNeeded);
      const x2 = toX(lastValid.dist), y2 = toY(lastValid.elev);
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = 'rgba(255,179,64,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Tower vertical
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255,179,64,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      
      // Label
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = 'rgba(255,179,64,1)';
      ctx.textAlign = 'left';
      ctx.fillText(`${startHeightNeeded.toFixed(1)}m`, x1 + 5, y1);
    }
    
    // Line from end tower to start
    if (endHeightNeeded > 0) {
      const x1 = toX(lastValid.dist), y1 = toY(lastValid.elev + endHeightNeeded);
      const x2 = toX(firstValid.dist), y2 = toY(firstValid.elev);
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = 'rgba(255,140,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Tower vertical
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255,140,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      
      // Label
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = 'rgba(255,140,100,1)';
      ctx.textAlign = 'right';
      ctx.fillText(`${endHeightNeeded.toFixed(1)}m`, x1 - 5, y1);
    }
    
    ctx.restore();
  }

  // Draw optimal combined tower heights
  if (showOptimalTowers && firstValid && lastValid) {
    const optimal = calculateOptimalTowerHeights(profileData, treeHeight);
    
    if (optimal.totalHeight < Infinity) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + optimal.startHeight);
      const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev + optimal.endHeight);

      ctx.save();
      ctx.setLineDash([8, 3]);
      ctx.strokeStyle = '#4effa0';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
      
      // Draw tower verticals
      ctx.save();
      ctx.strokeStyle = '#4effa0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
      
      // Add label
      ctx.save();
      ctx.font = '11px "IBM Plex Mono", monospace';
      ctx.fillStyle = '#4effa0';
      ctx.textAlign = 'center';
      ctx.fillText(`Optimal: ${optimal.startHeight.toFixed(1)}m + ${optimal.endHeight.toFixed(1)}m`, (x1+x2)/2, Math.min(y1,y2) - 10);
      ctx.restore();
    }
  }

  /* â”€â”€â”€ LINE OF SIGHT between start and end â”€â”€â”€ */
  if (showLOS && firstValid && lastValid) {
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev);
    const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev);

    // dashed style, colour depends on visibility
    ctx.save();
    ctx.setLineDash([8, 5]);
    ctx.lineDashOffset = 0;

    if (los && los.visible) {
      ctx.strokeStyle = 'rgba(78,255,160,0.7)';
    } else {
      ctx.strokeStyle = 'rgba(255,92,92,0.7)';
    }
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();

    // Mark obstruction entry/exit points
    if (los && !los.visible && los.blockages && los.blockages.length > 0) {
      const startTowerH = parseFloat(document.getElementById('startTowerHeight')?.value || 0);
      const endTowerH = parseFloat(document.getElementById('endTowerHeight')?.value || 0);
      const treeH = parseFloat(document.getElementById('treeHeight')?.value || 0);
      
      const startTerrainElev = firstValid ? firstValid.elev : 0;
      const endTerrainElev = lastValid ? lastValid.elev : 0;
      
      const startWithTower = startTerrainElev + startTowerH;
      const endWithTower = endTerrainElev + endTowerH;
      
      ctx.save();
      ctx.strokeStyle = var_danger();
      ctx.lineWidth = 2;
      
      los.blockages.forEach(block => {
        // Skip if this blockage is at the start and observer tower clears it
        if (block.dist < 0.01 && startWithTower >= block.elev) return;
        
        // Skip if this blockage is at the end and remote tower clears it
        const distFromEnd = Math.abs(block.dist - (lastValid ? lastValid.dist : 0));
        if (distFromEnd < 0.01 && endWithTower >= block.elev) return;
        
        // Draw X mark at this transition point
        const bx = toX(block.dist);
        const by = toY(block.elev);
        
        ctx.beginPath();
        ctx.moveTo(bx-6, by-6); ctx.lineTo(bx+6, by+6);
        ctx.moveTo(bx+6, by-6); ctx.lineTo(bx-6, by+6);
        ctx.stroke();
      });
      
      ctx.restore();
    }
  }

  /* start / end dots */
  if (firstValid) {
    ctx.beginPath();
    ctx.arc(toX(firstValid.dist), toY(firstValid.elev), 5, 0, Math.PI*2);
    ctx.fillStyle = '#4effa0'; ctx.fill();
    ctx.strokeStyle = '#0a0c0f'; ctx.lineWidth = 2.5; ctx.stroke();
  }
  if (lastValid) {
    ctx.beginPath();
    ctx.arc(toX(lastValid.dist), toY(lastValid.elev), 5, 0, Math.PI*2);
    ctx.fillStyle = '#4e9fff'; ctx.fill();
    ctx.strokeStyle = '#0a0c0f'; ctx.lineWidth = 2.5; ctx.stroke();
  }

  canvas._drawParams = { pad, pw, ph, toX, toY, minElev, maxElev, maxDist, elevRange, padElev };
}

function var_danger() { return '#ff5c5c'; }

// Auto-update profile when options change
['showLOS', 'showUserTowers', 'showMinTowers', 'showOptimalTowers'].forEach(id => {
  document.getElementById(id)?.addEventListener('change', () => {
    if (profileData.length > 0) drawProfile(cachedLOS);
  });
});

['startTowerHeight', 'endTowerHeight', 'treeHeight'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      if (profileData.length > 0) drawProfile(cachedLOS);
    });
  }
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATUS MESSAGE
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function setStatus(msg, isError) {
  statusMsg.textContent = msg;
  statusMsg.classList.toggle('error', isError);
  statusMsg.style.display = msg ? 'block' : 'none';
}

/* â”€â”€â”€ PROFILE TOOLTIP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
canvas.addEventListener('mousemove', e => {
  if (!canvas._drawParams || !profileData.length) return;
  const rect = canvas.getBoundingClientRect();
  const mx   = e.clientX - rect.left;
  const { pad, maxDist } = canvas._drawParams;
  const pw = rect.width - pad.left - pad.right;
  const d  = ((mx - pad.left) / pw) * maxDist;
  if (d < 0 || d > maxDist) { tooltip.classList.remove('visible'); return; }

  let closest = null, bestDiff = Infinity;
  profileData.forEach(p => { if (p.elev===null) return; const diff=Math.abs(p.dist-d); if(diff<bestDiff){bestDiff=diff;closest=p;} });
  if (!closest) { tooltip.classList.remove('visible'); return; }

  document.getElementById('ttElev').textContent = Math.round(closest.elev)+' m';
  document.getElementById('ttDist').textContent = ' Â· '+closest.dist.toFixed(2)+' km';
  tooltip.style.left = (mx+14)+'px';
  tooltip.style.top  = (e.clientY - rect.top - 20)+'px';
  tooltip.classList.add('visible');
});
canvas.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GENERATE RADIAL LOS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
document.getElementById('btnGenerateRadial')?.addEventListener('click', generateRadial);

function generateRadial() {
  const lat     = parseFloat(document.getElementById('obsLat').value);
  const lng     = parseFloat(document.getElementById('obsLng').value);
  const radius  = parseFloat(document.getElementById('radRadius').value);
  const angRes  = parseFloat(document.getElementById('radAngRes').value);
  // Use the same sample count as Aâ†’B profile for consistency
  const samples = parseInt(document.getElementById('sampleCount').value);
  const obsH    = parseFloat(document.getElementById('obsHeight').value) || 0;
  const remoteH = 0; // Remote tower always 0 for radial LOS
  const treeH   = parseFloat(document.getElementById('treeHeight')?.value || 5);

  if (isNaN(lat)||isNaN(lng)||isNaN(radius)) { 
    setStatus('Observer location and radius are required.', true); 
    return; 
  }
  if (radius <= 0) { 
    setStatus('Radius must be > 0.', true); 
    return; 
  }

  observerLocation = { lat, lng };

  const obsElev = getElevation(lat, lng);
  if (obsElev === null) { 
    setStatus('No elevation data at observer point â€” check tiles.', true); 
    return; 
  }

  const totalObsElev = obsElev + obsH;
  radialData = [];

  const numRays = Math.round(360 / angRes);
  let visCount = 0, blkCount = 0;

  setStatus('Computingâ€¦', false);

  setTimeout(() => {
    // Simple visibility check (no heatmap mode)
    if (false) {
      const maxTowerH = parseFloat(document.getElementById('radMaxTowerHeight')?.value || 50);
      
      for (let i = 0; i < numRays; i++) {
        const bearing = (i * angRes) % 360;
        const target  = destPoint(lat, lng, bearing, radius);
        const targetElev = getElevation(target.lat, target.lng) || 0;
        
        let minH = 0, maxH = maxTowerH;
        let requiredHeight = maxTowerH;
        
        for (let iter = 0; iter < 20; iter++) {
          const testH = (minH + maxH) / 2;
          const result = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, treeH, targetElev + testH);
          
          if (result.visible) {
            requiredHeight = testH;
            maxH = testH;
          } else {
            minH = testH;
          }
        }
        
        // Check actual visibility with the required height to get correct visibleDist
        const finalResult = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, treeH, targetElev + requiredHeight);
        
        radialData.push({
          bearing,
          visible: requiredHeight < maxTowerH,
          visibleDist: finalResult.visible ? radius : finalResult.visibleDist,
          blockElev: finalResult.blockElev,
          blockDist: finalResult.blockDist,
          requiredTowerHeight: requiredHeight
        });
        
        if (requiredHeight < maxTowerH) visCount++; else blkCount++;
      }
    } else {
      for (let i = 0; i < numRays; i++) {
        const bearing = (i * angRes) % 360;
        const target  = destPoint(lat, lng, bearing, radius);
        const targetElev = getElevation(target.lat, target.lng);
        if (targetElev === null) continue;
        
        const totalTargetElev = targetElev + remoteH;
        
        // Generate profile data for this ray
        const rayProfileData = [];
        for (let j = 0; j <= samples; j++) {
          const t = j / samples;
          const pt = interpolateLine(lat, lng, target.lat, target.lng, t);
          const elev = getElevation(pt.lat, pt.lng);
          const d = radius * t;
          rayProfileData.push({ dist: d, elev: elev !== null ? elev : null });
        }
        
        const result  = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, treeH, totalTargetElev);

        radialData.push({
          bearing,
          visible:     result.visible,
          visibleDist: result.visibleDist,
          blockElev:   result.blockElev,
          blockDist:   result.blockDist,
          blockages:   result.blockages,
          profileData: rayProfileData,
          losResult:   result
        });
        if (result.visible) visCount++; else blkCount++;
      }
    }

    setStatus(`Radial scan complete Â· ${numRays} rays Â· ${visCount} visible Â· ${blkCount} blocked`, false);
    
    // First draw to get the map parameters
    drawTerrainMap();
    
    // Zoom into radial LOS area - calculate actual extent of radial lines
    if (observerLocation && radialData && radialData.length > 0 && mapCanvas._mapParams) {
      // Find the actual extent of the radial lines
      let radMinLat = observerLocation.lat, radMaxLat = observerLocation.lat;
      let radMinLng = observerLocation.lng, radMaxLng = observerLocation.lng;
      
      radialData.forEach(ray => {
        const endPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, ray.visibleDist);
        radMinLat = Math.min(radMinLat, endPoint.lat);
        radMaxLat = Math.max(radMaxLat, endPoint.lat);
        radMinLng = Math.min(radMinLng, endPoint.lng);
        radMaxLng = Math.max(radMaxLng, endPoint.lng);
      });
      
      // Get map parameters from the drawn canvas
      const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H } = mapCanvas._mapParams;
      
      // Add padding to radial extent (10% on each side)
      const radLatRange = (radMaxLat - radMinLat) * 1.2;
      const radLngRange = (radMaxLng - radMinLng) * 1.2;
      
      // Calculate zoom to fit radial area
      const zoomLat = latRange / radLatRange;
      const zoomLng = lngRange / radLngRange;
      mapZoom = Math.min(zoomLat, zoomLng, 10); // Cap at 10x
      
      // Calculate offset to center on observer
      // Observer position in canvas data coordinates (0,0 to W,H):
      const obsPosX = W * (observerLocation.lng - minLng) / lngRange;
      const obsPosY = H * (1 - (observerLocation.lat - minLat) / latRange);
      
      // Transform: translate(W/2, H/2) -> scale(zoom) -> translate(-W/2 + offsetX, -H/2 + offsetY)
      // For observer at (obsPosX, obsPosY) to be at screen center (W/2, H/2):
      // W/2 + (obsPosX - W/2 + offsetX) * zoom = W/2
      // (obsPosX - W/2 + offsetX) * zoom = 0
      // offsetX = W/2 - obsPosX
      mapOffsetX = W/2 - obsPosX;
      mapOffsetY = H/2 - obsPosY;
      
      document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';
      drawTerrainMap();
    }
  }, 30);
}

}); // End DOMContentLoaded
</script>
</body>
</html>
