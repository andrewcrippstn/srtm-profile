<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>SRTM Terrain Profile</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #0a0c0f;
    --bg-panel: #111418;
    --bg-input: #161a22;
    --border: #2a3040;
    --border-focus: #4e9fff;
    --text: #c8d0dc;
    --text-dim: #606878;
    --accent: #4e9fff;
    --accent-warm: #ffb340;
    --accent-green: #4effa0;
    --danger: #ff5c5c;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'IBM Plex Mono', monospace;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* ‚îÄ‚îÄ‚îÄ Header ‚îÄ‚îÄ‚îÄ */
  header {
    border-bottom: 1px solid var(--border);
    padding: 16px 24px;
    background: var(--bg-panel);
    flex-shrink: 0;
  }
  .header-inner { display: flex; align-items: center; gap: 24px; }
  h1 { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 1.3rem; letter-spacing: -0.02em; color: #fff; }
  h1 span { color: var(--accent); }
  .header-sub { font-size: 0.68rem; color: var(--text-dim); letter-spacing: 0.08em; text-transform: uppercase; margin-left: auto; }
  
  /* ‚îÄ‚îÄ‚îÄ Navigation Dropdown ‚îÄ‚îÄ‚îÄ */
  .nav-dropdown {
    position: relative;
    margin-left: 24px;
  }
  .nav-dropdown select {
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: inherit;
    font-size: 0.75rem;
    padding: 8px 32px 8px 12px;
    cursor: pointer;
    transition: border-color 0.2s;
    outline: none;
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23c8d0dc' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 10px center;
  }
  .nav-dropdown select:hover {
    border-color: var(--border-focus);
  }
  .nav-dropdown select:focus {
    border-color: var(--border-focus);
  }

  /* ‚îÄ‚îÄ‚îÄ Main Layout ‚îÄ‚îÄ‚îÄ */
  .main-layout {
    display: flex;
    flex: 1;
    overflow: hidden;
    position: relative;
  }
  
  .terrain-map-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--bg);
    position: relative;
  }
  
  .right-panels {
    width: 420px;
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    overflow-y: auto;
  }
  
  .elevation-profile-section {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 420px;
    height: 380px;
    background: var(--bg-panel);
    border-top: 2px solid var(--border);
    border-right: 2px solid var(--border);
    display: none;
    flex-direction: column;
    z-index: 10;
  }
  
  .elevation-profile-section.visible { display: flex; }
  
  .profile-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 16px 24px;
    min-height: 0;
  }
  
  .profile-options-section {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 420px;
    height: 280px;
    background: var(--bg-panel);
    border-top: 2px solid var(--border);
    border-left: 1px solid var(--border);
    display: none;
    flex-direction: column;
    z-index: 10;
    overflow-y: auto;
  }
  
  .profile-options-section.visible { display: flex; }
  
  .input-data-section {
    background: var(--bg-panel);
    display: flex;
    flex-direction: column;
  }

  /* ‚îÄ‚îÄ‚îÄ Section Headers ‚îÄ‚îÄ‚îÄ */
  .section-header {
    padding: 12px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 12px;
    flex-shrink: 0;
  }
  
  .import-section {
    border-bottom: 1px solid var(--border);
    background: var(--bg-panel);
  }
  
  .import-toggle-btn {
    width: 100%;
    background: var(--bg-input);
    border: none;
    border-bottom: 1px solid var(--border);
    color: var(--text);
    padding: 10px 24px;
    font-family: inherit;
    font-size: 0.72rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.2s;
  }
  
  .import-toggle-btn:hover { background: var(--bg-panel); }
  .import-toggle-btn .arrow { transition: transform 0.2s; }
  .import-toggle-btn.open .arrow { transform: rotate(90deg); }
  
  .import-content {
    display: none;
    padding: 12px 24px;
  }
  
  .import-content.open { display: block; }
  .section-title {
    font-size: 0.68rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--accent);
    font-weight: 500;
  }
  .section-title::before {
    content: '';
    display: inline-block;
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 6px var(--accent);
    margin-right: 8px;
  }

  /* ‚îÄ‚îÄ‚îÄ Tabs ‚îÄ‚îÄ‚îÄ */
  .tab-toggle {
    display: flex;
    gap: 4px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px;
    width: fit-content;
    margin-bottom: 16px;
  }
  .tab-btn {
    font-family: inherit;
    font-size: 0.72rem;
    letter-spacing: 0.06em;
    padding: 6px 14px;
    border: none;
    border-radius: 6px;
    background: transparent;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s;
  }
  .tab-btn:hover { background: rgba(78,159,255,0.1); color: var(--accent); }
  .tab-btn.active { background: var(--accent); color: #0a0c0f; font-weight: 500; }
  
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* ‚îÄ‚îÄ‚îÄ Inputs ‚îÄ‚îÄ‚îÄ */
  .input-wrap label { display: block; font-size: 0.62rem; color: var(--text-dim); margin-bottom: 3px; letter-spacing: 0.06em; }
  .input-wrap input, .input-wrap select {
    width: 100%;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: #fff;
    font-family: inherit;
    font-size: 0.82rem;
    padding: 8px 10px;
    transition: border-color 0.2s;
    outline: none;
  }
  .input-wrap input:focus, .input-wrap select:focus { border-color: var(--border-focus); }

  /* ‚îÄ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ‚îÄ */
  .btn {
    font-family: inherit;
    font-size: 0.72rem;
    letter-spacing: 0.1em;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }
  .btn-primary {
    background: var(--accent);
    color: #0a0c0f;
    font-weight: 500;
  }
  .btn-primary:hover { background: #6eb0ff; transform: translateY(-1px); }
  .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
  .btn-secondary {
    background: var(--bg-input);
    color: var(--text);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }

  /* ‚îÄ‚îÄ‚îÄ Dropzone ‚îÄ‚îÄ‚îÄ */
  .dropzone {
    border: 2px dashed var(--border);
    border-radius: 8px;
    padding: 16px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    background: var(--bg-input);
    font-size: 0.75rem;
  }
  .dropzone:hover, .dropzone.dragover { border-color: var(--accent); background: rgba(78,159,255,0.04); }
  .dropzone input { display: none; }
  .dropzone em { color: var(--accent); font-style: normal; }

  /* ‚îÄ‚îÄ‚îÄ Tile List ‚îÄ‚îÄ‚îÄ */
  .tile-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }
  .tile-tag {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 4px 8px;
    font-size: 0.7rem;
  }
  .tag-name { color: var(--accent); font-weight: 500; }
  .tag-res { color: var(--text-dim); font-size: 0.65rem; }
  .tag-remove {
    color: var(--danger);
    cursor: pointer;
    margin-left: 4px;
    font-size: 0.9rem;
  }
  .tag-remove:hover { color: #ff8c8c; }

  /* ‚îÄ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ‚îÄ */
  .canvas-wrap {
    position: relative;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }
  canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
  }
  #profileCanvas {
    width: 100% !important;
    height: 100% !important;
  }
  #terrainMapCanvas { cursor: crosshair; }
  #terrainMapCanvas.panning { cursor: grabbing; }

  /* ‚îÄ‚îÄ‚îÄ Map Controls ‚îÄ‚îÄ‚îÄ */
  .minimap {
    position: absolute;
    bottom: 12px;
    right: 12px;
    width: 120px;
    height: 120px;
    border: 2px solid var(--border);
    border-radius: 6px;
    background: rgba(10,12,15,0.8);
    cursor: pointer;
  }
  .zoom-indicator {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(10,12,15,0.9);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 12px;
    font-size: 0.72rem;
    color: var(--accent);
    font-weight: 500;
  }
  .map-hover-info {
    position: absolute;
    background: rgba(10,12,15,0.95);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 0.7rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .map-hover-info.visible { opacity: 1; }
  .info-label { color: var(--text-dim); margin-right: 6px; }
  .info-value { color: var(--accent); font-weight: 500; }

  /* ‚îÄ‚îÄ‚îÄ Checkbox ‚îÄ‚îÄ‚îÄ */
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .checkbox-group input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
  }
  .checkbox-group label {
    font-size: 0.75rem;
    cursor: pointer;
    margin: 0;
  }

  /* ‚îÄ‚îÄ‚îÄ Profile Stats ‚îÄ‚îÄ‚îÄ */
  .profile-stats {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .stat {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }
  .stat-label {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }
  .stat-value {
    font-size: 0.85rem;
    color: var(--accent);
    font-weight: 500;
  }

  /* ‚îÄ‚îÄ‚îÄ Profile Options ‚îÄ‚îÄ‚îÄ */
  .profile-options {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 12px;
  }
  .option-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .option-group label {
    font-size: 0.62rem;
    color: var(--text-dim);
    letter-spacing: 0.06em;
  }
  .option-group input {
    width: 80px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: #fff;
    font-size: 0.78rem;
    padding: 4px 8px;
    text-align: center;
  }

  /* ‚îÄ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ‚îÄ */
  .tooltip {
    position: absolute;
    background: rgba(10,12,15,0.95);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 0.7rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
    white-space: nowrap;
  }
  .tooltip.visible { opacity: 1; }
  .tt-elev { color: var(--accent); font-weight: 500; }
  .tt-dist { color: var(--text-dim); }

  /* ‚îÄ‚îÄ‚îÄ Status Message ‚îÄ‚îÄ‚îÄ */
  .status-msg {
    font-size: 0.72rem;
    padding: 8px 12px;
    border-radius: 6px;
    background: var(--bg-input);
    border: 1px solid var(--border);
  }
  .status-msg.error {
    background: rgba(255,92,92,0.1);
    border-color: var(--danger);
    color: var(--danger);
  }

  /* ‚îÄ‚îÄ‚îÄ Info Text ‚îÄ‚îÄ‚îÄ */
  .info-text {
    font-size: 0.7rem;
    color: var(--text-dim);
    font-style: italic;
    padding: 8px 0;
  }

  /* ‚îÄ‚îÄ‚îÄ Map Info Footer ‚îÄ‚îÄ‚îÄ */
  .map-info {
    padding: 8px 24px;
    font-size: 0.68rem;
    color: var(--text-dim);
    border-top: 1px solid var(--border);
  }
  
  /* ‚îÄ‚îÄ‚îÄ Page Sections ‚îÄ‚îÄ‚îÄ */
  .page-section {
    display: none;
    flex: 1;
    overflow: hidden;
  }
  .page-section.active {
    display: flex;
  }
  
  #terrainPage {
    flex-direction: row;
  }
  
  /* ‚îÄ‚îÄ‚îÄ Site Data Page ‚îÄ‚îÄ‚îÄ */
  .site-data-page {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--bg);
    padding: 24px;
    overflow-y: auto;
  }
  
  .site-data-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 24px;
  }
  
  .site-data-header h2 {
    font-family: 'Syne', sans-serif;
    font-size: 1.5rem;
    color: var(--accent);
  }
  
  .site-form {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 24px;
  }
  
  .site-form h3 {
    font-size: 0.85rem;
    color: var(--accent);
    margin-bottom: 16px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }
  
  .form-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 2fr 2fr;
    gap: 12px;
    margin-bottom: 16px;
  }
  
  .form-actions {
    display: flex;
    gap: 8px;
  }
  
  .site-table-container {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  
  .site-table {
    width: 100%;
    border-collapse: collapse;
  }
  
  .site-table thead {
    background: var(--bg-input);
    border-bottom: 1px solid var(--border);
  }
  
  .site-table th {
    padding: 12px 16px;
    text-align: left;
    font-size: 0.7rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-weight: 500;
  }
  
  .site-table td {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    font-size: 0.8rem;
  }
  
  .site-table tbody tr:hover {
    background: rgba(78,159,255,0.05);
  }
  
  .site-table tbody tr:last-child td {
    border-bottom: none;
  }
  
  .site-actions {
    display: flex;
    gap: 8px;
  }
  
  .btn-icon {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text);
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.2s;
  }
  
  .btn-icon:hover {
    border-color: var(--accent);
    color: var(--accent);
  }
  
  .btn-icon.danger:hover {
    border-color: var(--danger);
    color: var(--danger);
  }
  
  /* ‚îÄ‚îÄ‚îÄ HGT Import Page ‚îÄ‚îÄ‚îÄ */
  .hgt-import-page {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--bg);
    padding: 24px;
    overflow-y: auto;
  }
  
  .hgt-import-header {
    margin-bottom: 24px;
  }
  
  .hgt-import-header h2 {
    font-family: 'Syne', sans-serif;
    font-size: 1.5rem;
    color: var(--accent);
    margin-bottom: 8px;
  }
  
  .hgt-import-header p {
    font-size: 0.8rem;
    color: var(--text-dim);
  }
  
  .import-panel {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 20px;
  }
</style>
</head>
<body>

<header>
  <div class="header-inner">
    <h1>SRTM <span>Terrain Profile</span></h1>
    <div class="nav-dropdown">
      <select id="pageSelector">
        <option value="terrain">Terrain Profile</option>
        <option value="import">Import HGT Tiles</option>
        <option value="sites">Site Data</option>
      </select>
    </div>
    <div class="header-sub">elevation ¬∑ line of sight</div>
  </div>
</header>

<div class="main-layout">
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       TERRAIN PROFILE PAGE (Main terrain map and profile)
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="page-section active" id="terrainPage">
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       TERRAIN MAP SECTION (Full screen with right panel)
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="terrain-map-section">
    <div class="canvas-wrap" style="flex: 1;">
      <canvas id="terrainMapCanvas"></canvas>
      <canvas class="minimap" id="minimapCanvas"></canvas>
      <div class="zoom-indicator" id="zoomIndicator">1.0x</div>
      <div class="map-hover-info" id="mapHoverInfo">
        <div><span class="info-label">Lat:</span><span class="info-value" id="hoverLat">‚Äî</span></div>
        <div><span class="info-label">Lng:</span><span class="info-value" id="hoverLng">‚Äî</span></div>
        <div><span class="info-label">Elev:</span><span class="info-value" id="hoverElev">‚Äî</span></div>
        <div id="hoverSiteDiv" style="display: none; border-top: 1px solid var(--border); margin-top: 4px; padding-top: 4px;"><span class="info-label">Site:</span><span class="info-value" id="hoverSite">‚Äî</span></div>
      </div>
      <button class="btn btn-secondary" id="btnResetZoom" style="position: absolute; top: 12px; left: 12px; z-index: 5;">Reset Zoom</button>
    </div>
  </div>
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       ELEVATION PROFILE SECTION (Bottom Panel - Full Width)
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="elevation-profile-section" id="profilePanel">
    <div class="section-header">
      <span class="section-title">Elevation Profile</span>
      <div class="profile-stats" style="display: flex; gap: 20px; margin-left: auto; font-size: 0.7rem;">
        <div class="stat"><span class="stat-label">Distance:</span> <span class="stat-value" id="statDist">‚Äî</span></div>
        <div class="stat"><span class="stat-label">Max:</span> <span class="stat-value" id="statMax">‚Äî</span></div>
        <div class="stat"><span class="stat-label">Min:</span> <span class="stat-value" id="statMin">‚Äî</span></div>
        <div class="stat"><span class="stat-label">Start:</span> <span class="stat-value" id="statStart">‚Äî</span></div>
        <div class="stat"><span class="stat-label">End:</span> <span class="stat-value" id="statEnd">‚Äî</span></div>
        <div class="stat"><span class="stat-label">LOS:</span> <span class="stat-value" id="statLOS">‚Äî</span></div>
      </div>
    </div>
    <div class="profile-container">
      <div class="canvas-wrap" style="flex: 1; min-height: 0;">
        <canvas id="profileCanvas"></canvas>
        <div class="tooltip" id="tooltip">
          <span class="tt-elev" id="ttElev">0 m</span>
          <span class="tt-dist" id="ttDist"> ¬∑ 0 km</span>
        </div>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       PROFILE OPTIONS PANEL (Bottom Right)
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="profile-options-section" id="profileOptionsPanel">
    <div class="section-header">
      <span class="section-title">Profile Options</span>
    </div>
    <div style="padding: 16px 24px; display: flex; flex-direction: column; gap: 14px;">
      <div class="option-group">
        <label>Observer Tower (m)</label>
        <input type="number" id="startTowerHeight" value="10" min="0" step="1">
      </div>
      <div class="option-group">
        <label>Remote Tower (m)</label>
        <input type="number" id="endTowerHeight" value="10" min="0" step="1">
      </div>
      <div class="option-group">
        <label>Tree Height (m)</label>
        <input type="number" id="treeHeight" value="5" min="0" step="0.5">
      </div>
      <div style="font-size: 0.65rem; color: var(--text-dim); letter-spacing: 0.08em; margin-top: 8px; text-transform: uppercase;">Display Options</div>
      <div class="checkbox-group">
        <input type="checkbox" id="showLOS">
        <label for="showLOS">Line of Sight</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showUserTowers" checked>
        <label for="showUserTowers">Manual Towers</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showMinTowers">
        <label for="showMinTowers">Min Tower Heights</label>
      </div>
      <div class="checkbox-group">
        <input type="checkbox" id="showOptimalTowers">
        <label for="showOptimalTowers">Optimal Towers</label>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       RIGHT PANELS (Input Data)
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="right-panels">
    <div class="input-data-section">
      <div class="section-header">
        <span class="section-title">Input Data</span>
      </div>
    <div style="padding: 16px 24px;">
      
      <!-- Tabs -->
      <div class="tab-toggle">
        <button class="tab-btn active" data-tab="observer">Observer</button>
        <button class="tab-btn" data-tab="radial">Radial LOS</button>
        <button class="tab-btn" data-tab="ab">A‚ÜíB Profile</button>
      </div>
      
      <!-- Observer Tab -->
      <div class="tab-content active" id="tab-observer">
        <div style="display: flex; gap: 12px; margin-bottom: 14px;">
          <div class="input-wrap" style="flex: 1;">
            <label>Latitude</label>
            <input type="text" id="obsLat" placeholder="e.g. -42.8826" />
          </div>
          <div class="input-wrap" style="flex: 1;">
            <label>Longitude</label>
            <input type="text" id="obsLng" placeholder="e.g. 147.3257" />
          </div>
        </div>
        <div class="input-wrap" style="width: 180px; margin-bottom: 14px;">
          <label>Observer tower (m)</label>
          <input type="number" id="obsHeight" value="10" min="0" step="1" />
        </div>
        <div class="info-text">
          üí° Click on terrain map to set observer location
        </div>
      </div>
      
      <!-- Radial LOS Tab -->
      <div class="tab-content" id="tab-radial">
        <div style="display: flex; gap: 12px; margin-bottom: 14px; flex-wrap: wrap;">
          <div class="input-wrap" style="width: 140px;">
            <label>Radius (km)</label>
            <input type="text" id="radRadius" placeholder="e.g. 10" />
          </div>
          <div class="input-wrap" style="width: 140px;">
            <label>Angular res. (¬∞)</label>
            <select id="radAngRes">
              <option value="0.5">0.5¬∞ (720)</option>
              <option value="1" selected>1¬∞ (360)</option>
              <option value="2">2¬∞ (180)</option>
              <option value="5">5¬∞ (72)</option>
            </select>
          </div>
        </div>
        <button class="btn btn-primary" id="btnGenerateRadial">Generate Radial LOS</button>
        <div class="info-text">
          üí° Green sections have line of sight, red sections are blocked
        </div>
      </div>
      
      <!-- A‚ÜíB Profile Tab -->
      <div class="tab-content" id="tab-ab">
        <div style="margin-bottom: 6px; font-size: 0.68rem; color: var(--text-dim); letter-spacing: 0.06em;">
          ‚ñ∏ TARGET POINT
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 14px;">
          <div class="input-wrap">
            <label>Latitude</label>
            <input type="text" id="endLat" placeholder="e.g. -42.9826" />
          </div>
          <div class="input-wrap">
            <label>Longitude</label>
            <input type="text" id="endLng" placeholder="e.g. 147.4257" />
          </div>
        </div>
        <div class="input-wrap" style="width: 140px; margin-bottom: 14px;">
          <label>Samples</label>
          <select id="sampleCount">
            <option value="500">500</option>
            <option value="1000" selected>1 000</option>
            <option value="2000">2 000</option>
            <option value="5000">5 000</option>
          </select>
        </div>
        <button class="btn btn-primary" id="btnGenerateAB">Generate Profile</button>
      </div>
      
      <div class="status-msg" id="statusMsg" style="margin-top: 14px; display: none;"></div>
    </div>
  </div>
  
  </div><!-- End right-panels -->
  
  </div><!-- End terrainPage -->
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       HGT IMPORT PAGE
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="page-section" id="importPage">
    <div class="hgt-import-page">
      <div class="hgt-import-header">
        <h2>Import HGT Tiles</h2>
        <p>Import SRTM elevation data files (.hgt) to enable terrain analysis</p>
      </div>
      
      <div class="import-panel">
        <h3 style="font-size: 0.85rem; color: var(--accent); margin-bottom: 16px; letter-spacing: 0.08em; text-transform: uppercase;">Upload Files</h3>
        
        <div class="dropzone" id="dropzone2" style="margin-bottom: 16px;">
          <input type="file" id="fileInput2" accept=".hgt" multiple />
          <span>Drop <em>.hgt</em> files or <em>click</em></span>
        </div>
        
        <div style="display: flex; gap: 8px; margin-bottom: 16px;">
          <button class="btn btn-secondary" id="btnSaveTiles2">Save to Storage</button>
          <button class="btn btn-secondary" id="btnLoadTiles2">Load from Storage</button>
          <a href="https://viewfinderpanoramas.org/Coverage%20map%20viewfinderpanoramas_org3.htm" target="_blank" class="btn btn-secondary" style="text-decoration: none; display: inline-flex; align-items: center; justify-content: center;">Download HGT</a>
        </div>
        
        <div style="margin-bottom: 8px; font-size: 0.7rem; color: var(--text-dim);">Loaded Tiles:</div>
        <div class="tile-list" id="tileList2"></div>
      </div>
    </div>
  </div>
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       SITE DATA PAGE
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="page-section" id="sitesPage">
    <div class="site-data-page">
      <div class="site-data-header">
        <h2>Site Data</h2>
        <div style="display: flex; gap: 8px;">
          <button class="btn btn-secondary" id="btnImportSites">Import CSV</button>
          <button class="btn btn-primary" id="btnExportSites">Export CSV</button>
        </div>
      </div>
      
      <div class="site-form">
        <h3>Add New Site</h3>
        <div class="form-grid">
          <div class="input-wrap">
            <label>Latitude</label>
            <input type="text" id="siteLatInput" placeholder="-42.8826" />
          </div>
          <div class="input-wrap">
            <label>Longitude</label>
            <input type="text" id="siteLngInput" placeholder="147.3257" />
          </div>
          <div class="input-wrap">
            <label>Tag</label>
            <input type="text" id="siteTagInput" placeholder="HBT" />
          </div>
          <div class="input-wrap">
            <label>Name</label>
            <input type="text" id="siteNameInput" placeholder="Hobart" />
          </div>
        </div>
        <div class="form-actions">
          <button class="btn btn-primary" id="btnAddSite">Add Site</button>
          <button class="btn btn-secondary" id="btnClearForm">Clear</button>
        </div>
      </div>
      
      <div class="site-table-container">
        <table class="site-table">
          <thead>
            <tr>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Tag</th>
              <th>Name</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="siteTableBody">
            <!-- Sites will be populated here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
  
</div><!-- End main-layout -->

<script>
document.addEventListener('DOMContentLoaded', async function() {
// Version: 2026-02-03-14:30 - Force cache refresh
// Wrap everything in DOMContentLoaded to ensure DOM is ready

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   STATE
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const tiles = {};
let profileData  = [];
let radialData   = [];
let cachedLOS    = null;
let filesLoading = 0;
let observerLocation = null; // {lat, lng}
let targetLocation = null;   // {lat, lng} for A‚ÜíB - the blue line target
let hoverLocation = null;    // {lat, lng} for hover target on A‚ÜíB tab
let hoverDistance = null;    // distance along radial line where mouse is hovering
let blueLineProfileData = []; // Store blue line profile data
let blueLineLOS = null;       // Store blue line LOS result
let sites = [];               // Array of site objects: {lat, lng, tag, name}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   INDEXEDDB HELPERS (for large HGT files)
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
let db = null;

function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('SRTMDatabase', 2);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('tiles')) {
        db.createObjectStore('tiles', { keyPath: 'key' });
      }
      if (!db.objectStoreNames.contains('sites')) {
        db.createObjectStore('sites', { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

function saveTilesToStorage() {
  if (!db) {
    return;
  }
  
  try {
    const transaction = db.transaction(['tiles'], 'readwrite');
    const store = transaction.objectStore('tiles');
    
    store.clear();
    
    Object.keys(tiles).forEach(key => {
      store.put({
        key: key,
        data: Array.from(tiles[key].data),
        size: tiles[key].size
      });
    });
    
    transaction.oncomplete = () => {
      setStatus(`Saved ${Object.keys(tiles).length} tiles to browser storage`, false);
    };
    
    transaction.onerror = () => {
      setStatus('Error saving tiles: ' + transaction.error, true);
    };
  } catch (e) {
    setStatus('Error saving tiles: ' + e.message, true);
  }
}

function loadTilesFromStorage() {
  if (!db) {
    return;
  }
  
  try {
    const transaction = db.transaction(['tiles'], 'readonly');
    const store = transaction.objectStore('tiles');
    const request = store.getAll();
    
    request.onsuccess = () => {
      const savedTiles = request.result;
      if (savedTiles.length === 0) {
        setStatus('No saved tiles found', false);
        return;
      }
      
      Object.keys(tiles).forEach(k => delete tiles[k]);
      savedTiles.forEach(tile => {
        tiles[tile.key] = {
          data: new Int16Array(tile.data),
          size: tile.size
        };
      });
      
      renderTileTags();
      
      mapZoom = 1;
      mapOffsetX = 0;
      mapOffsetY = 0;
      
      setTimeout(() => {
        drawTerrainMap();
      }, 50);
      
      setStatus(`Loaded ${Object.keys(tiles).length} tiles from browser storage`, false);
    };
    
    request.onerror = () => {
      setStatus('Error loading tiles: ' + request.error, true);
    };
  } catch (e) {
    setStatus('Error loading tiles: ' + e.message, true);
  }
}

function saveInputsToStorage() {
  try {
    const inputs = {
      obsLat: document.getElementById('obsLat')?.value || '',
      obsLng: document.getElementById('obsLng')?.value || '',
      obsHeight: document.getElementById('obsHeight')?.value || '10',
      endLat: document.getElementById('endLat')?.value || '',
      endLng: document.getElementById('endLng')?.value || '',
      radRadius: document.getElementById('radRadius')?.value || '',
      startTowerHeight: document.getElementById('startTowerHeight')?.value || '10',
      endTowerHeight: document.getElementById('endTowerHeight')?.value || '10',
      treeHeight: document.getElementById('treeHeight')?.value || '5',
      radMaxTowerHeight: document.getElementById('radMaxTowerHeight')?.value || '50'
    };
    localStorage.setItem('srtm_inputs', JSON.stringify(inputs));
  } catch (e) {
    // Silent error
  }
}

function loadInputsFromStorage() {
  try {
    const saved = localStorage.getItem('srtm_inputs');
    if (!saved) return;
    const inputs = JSON.parse(saved);
    Object.keys(inputs).forEach(key => {
      const el = document.getElementById(key);
      if (el && inputs[key] !== undefined) {
        el.value = inputs[key];
      }
    });
    
    // If observer location was preloaded, set it and display on map
    const obsLat = parseFloat(inputs.obsLat);
    const obsLng = parseFloat(inputs.obsLng);
    if (!isNaN(obsLat) && !isNaN(obsLng)) {
      observerLocation = { lat: obsLat, lng: obsLng };
      drawTerrainMap();
    }
    
    // If target location was preloaded, set it
    const endLat = parseFloat(inputs.endLat);
    const endLng = parseFloat(inputs.endLng);
    if (!isNaN(endLat) && !isNaN(endLng)) {
      targetLocation = { lat: endLat, lng: endLng };
    }
  } catch (e) {
    // Silent error
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   SITE DATA MANAGEMENT
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function loadSitesFromStorage() {
  if (!db) return;
  
  try {
    const transaction = db.transaction(['sites'], 'readonly');
    const store = transaction.objectStore('sites');
    const request = store.getAll();
    
    request.onsuccess = () => {
      const savedSites = request.result;
      if (savedSites.length === 0) {
        // Preload default sites for Tasmania
        sites = [
          { lat: -42.8826, lng: 147.3257, tag: 'HBT', name: 'Hobart' },
          { lat: -41.4332, lng: 147.1441, tag: 'LST', name: 'Launceston' },
          { lat: -41.1761, lng: 146.3158, tag: 'DVP', name: 'Devonport' }
        ];
        saveSitesToStorage();
      } else {
        sites = savedSites;
      }
      renderSiteTable();
      drawTerrainMap();
    };
  } catch (e) {
    // Silent error
  }
}

function saveSitesToStorage() {
  if (!db) return;
  
  try {
    const transaction = db.transaction(['sites'], 'readwrite');
    const store = transaction.objectStore('sites');
    
    store.clear();
    
    sites.forEach(site => {
      store.put(site);
    });
  } catch (e) {
    // Silent error
  }
}

function addSite(lat, lng, tag, name) {
  const site = { lat, lng, tag, name };
  sites.push(site);
  saveSitesToStorage();
  renderSiteTable();
  drawTerrainMap();
}

function deleteSite(index) {
  sites.splice(index, 1);
  saveSitesToStorage();
  renderSiteTable();
  drawTerrainMap();
}

function editSite(index) {
  const site = sites[index];
  document.getElementById('siteLatInput').value = site.lat;
  document.getElementById('siteLngInput').value = site.lng;
  document.getElementById('siteTagInput').value = site.tag;
  document.getElementById('siteNameInput').value = site.name;
  deleteSite(index);
}

function renderSiteTable() {
  const tbody = document.getElementById('siteTableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  
  sites.forEach((site, index) => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${site.lat.toFixed(4)}</td>
      <td>${site.lng.toFixed(4)}</td>
      <td>${site.tag}</td>
      <td>${site.name}</td>
      <td>
        <div class="site-actions">
          <button class="btn-icon" onclick="editSite(${index})" title="Edit">‚úèÔ∏è</button>
          <button class="btn-icon danger" onclick="deleteSite(${index})" title="Delete">üóëÔ∏è</button>
        </div>
      </td>
    `;
    tbody.appendChild(row);
  });
}

function exportSites() {
  // Create CSV content
  let csv = 'Latitude,Longitude,Tag,Name\n';
  sites.forEach(site => {
    csv += `${site.lat},${site.lng},"${site.tag}","${site.name}"\n`;
  });
  
  const dataBlob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'sites.csv';
  link.click();
  URL.revokeObjectURL(url);
}

function importSites() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.csv,text/csv';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const csv = event.target.result;
        const lines = csv.split('\n').filter(line => line.trim());
        
        // Skip header row
        const imported = [];
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i];
          // Simple CSV parsing (handles quoted fields)
          const matches = line.match(/([^,"]+|"[^"]*")+/g);
          if (matches && matches.length >= 4) {
            const lat = parseFloat(matches[0]);
            const lng = parseFloat(matches[1]);
            const tag = matches[2].replace(/^"|"$/g, '').trim();
            const name = matches[3].replace(/^"|"$/g, '').trim();
            
            if (!isNaN(lat) && !isNaN(lng)) {
              imported.push({ lat, lng, tag, name });
            }
          }
        }
        
        if (imported.length > 0) {
          sites = imported;
          saveSitesToStorage();
          renderSiteTable();
          drawTerrainMap();
          setStatus(`Imported ${sites.length} sites`, false);
        } else {
          setStatus('No valid sites found in CSV', true);
        }
      } catch (e) {
        setStatus('Error importing sites: invalid CSV', true);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DOM ELEMENTS
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const dropzone     = document.getElementById('dropzone');
const fileInput    = document.getElementById('fileInput');
const tileList     = document.getElementById('tileList');
const statusMsg    = document.getElementById('statusMsg');

const dropzone2    = document.getElementById('dropzone2');
const fileInput2   = document.getElementById('fileInput2');
const tileList2    = document.getElementById('tileList2');

const mapCanvas    = document.getElementById('terrainMapCanvas');
const mctx         = mapCanvas.getContext('2d');
const minimapCanvas= document.getElementById('minimapCanvas');
const miniCtx      = minimapCanvas.getContext('2d');
const mapHoverInfo = document.getElementById('mapHoverInfo');

let mapZoom = 1;
let mapOffsetX = 0;
let mapOffsetY = 0;
let mapIsPanning = false;
let mapWasPanning = false;
let mapLastX = 0;
let mapLastY = 0;

const canvas       = document.getElementById('profileCanvas');
const ctx          = canvas.getContext('2d');
const tooltip      = document.getElementById('tooltip');

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   INITIALIZATION
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
// Initialize database
try {
  await initDB();
  loadTilesFromStorage();
  loadSitesFromStorage();
} catch (e) {
  setStatus('Failed to initialize storage: ' + e.message, true);
}

loadInputsFromStorage();

// Page navigation
document.getElementById('pageSelector')?.addEventListener('change', (e) => {
  const page = e.target.value;
  document.querySelectorAll('.page-section').forEach(p => p.classList.remove('active'));
  
  if (page === 'terrain') {
    document.getElementById('terrainPage').classList.add('active');
  } else if (page === 'import') {
    document.getElementById('importPage').classList.add('active');
  } else if (page === 'sites') {
    document.getElementById('sitesPage').classList.add('active');
  }
});

// Site data event handlers
const btnAddSite = document.getElementById('btnAddSite');
if (btnAddSite) {
  btnAddSite.addEventListener('click', () => {
    const lat = parseFloat(document.getElementById('siteLatInput').value);
    const lng = parseFloat(document.getElementById('siteLngInput').value);
    const tag = document.getElementById('siteTagInput').value.trim();
    const name = document.getElementById('siteNameInput').value.trim();
  
  if (isNaN(lat) || isNaN(lng) || !tag || !name) {
    alert('Please fill in all fields with valid data');
    return;
  }
  
  addSite(lat, lng, tag, name);
  
  // Clear form
  document.getElementById('siteLatInput').value = '';
  document.getElementById('siteLngInput').value = '';
  document.getElementById('siteTagInput').value = '';
  document.getElementById('siteNameInput').value = '';
  });
}

const btnClearForm = document.getElementById('btnClearForm');
if (btnClearForm) {
  btnClearForm.addEventListener('click', () => {
    document.getElementById('siteLatInput').value = '';
    document.getElementById('siteLngInput').value = '';
    document.getElementById('siteTagInput').value = '';
    document.getElementById('siteNameInput').value = '';
  });
}

const btnExportSites = document.getElementById('btnExportSites');
if (btnExportSites) btnExportSites.addEventListener('click', exportSites);

const btnImportSites = document.getElementById('btnImportSites');
if (btnImportSites) btnImportSites.addEventListener('click', importSites);

// Make functions globally accessible for inline onclick handlers
window.editSite = editSite;
window.deleteSite = deleteSite;

// Auto-save inputs on change
['obsLat','obsLng','obsHeight','endLat','endLng','radRadius','startTowerHeight','endTowerHeight','treeHeight','radMaxTowerHeight'].forEach(id => {
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', saveInputsToStorage);
});

// Sync observer tower height between Observer tab and Profile Options
document.getElementById('obsHeight')?.addEventListener('input', (e) => {
  document.getElementById('startTowerHeight').value = e.target.value;
  if (profileData.length > 0) drawProfile(cachedLOS);
});
document.getElementById('startTowerHeight')?.addEventListener('input', (e) => {
  document.getElementById('obsHeight').value = e.target.value;
  if (profileData.length > 0) drawProfile(cachedLOS);
});

// Auto-update observer location when manual observer coordinates change
['obsLat', 'obsLng'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      const obsLat = parseFloat(document.getElementById('obsLat').value);
      const obsLng = parseFloat(document.getElementById('obsLng').value);
      
      if (!isNaN(obsLat) && !isNaN(obsLng)) {
        observerLocation = { lat: obsLat, lng: obsLng };
        radialData = []; // Clear radial lines when observer moves
        drawTerrainMap();
      }
    });
  }
});

// Auto-update A‚ÜíB profile when target coordinates change
['endLat', 'endLng'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      const obsLat = parseFloat(document.getElementById('obsLat').value);
      const obsLng = parseFloat(document.getElementById('obsLng').value);
      const endLat = parseFloat(document.getElementById('endLat').value);
      const endLng = parseFloat(document.getElementById('endLng').value);
      
      if (!isNaN(obsLat) && !isNaN(obsLng) && !isNaN(endLat) && !isNaN(endLng)) {
        targetLocation = { lat: endLat, lng: endLng };
        drawTerrainMap();
        // Debounce profile generation
        clearTimeout(window._profileUpdateTimer);
        window._profileUpdateTimer = setTimeout(() => {
          generateProfile();
        }, 500);
      }
    });
  }
});

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   TAB SWITCHING
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function getActiveTab() {
  const activeBtn = document.querySelector('.tab-btn.active');
  return activeBtn ? activeBtn.dataset.tab : null;
}

document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.dataset.tab;
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b === btn));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.toggle('active', c.id === `tab-${tab}`));
    
    // Clear radial lines when switching to Observer tab
    if (tab === 'observer') {
      radialData = [];
      drawTerrainMap();
    }
    
    // Show profile panels for A‚ÜíB tab
    const profilePanel = document.getElementById('profilePanel');
    const profileOptionsPanel = document.getElementById('profileOptionsPanel');
    if (tab === 'ab' && profileData.length > 0) {
      profilePanel.classList.add('visible');
      profileOptionsPanel.classList.add('visible');
    } else {
      profilePanel.classList.remove('visible');
      profileOptionsPanel.classList.remove('visible');
    }
  });
});

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DROPZONE / FILE LOADING
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
if (dropzone && fileInput) {
  dropzone.addEventListener('click', () => fileInput.click());
  dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
  dropzone.addEventListener('dragleave', e => { e.preventDefault(); dropzone.classList.remove('dragover'); });
  dropzone.addEventListener('drop', e => { e.preventDefault(); dropzone.classList.remove('dragover'); loadFiles(e.dataTransfer.files); });
  fileInput.addEventListener('change', e => loadFiles(e.target.files));
}

function loadFiles(files) {
  const hgtFiles = Array.from(files).filter(f => f.name.toLowerCase().endsWith('.hgt'));
  if (hgtFiles.length === 0) { setStatus('Please drop .hgt files only.', true); return; }
  
  filesLoading = hgtFiles.length;
  
  hgtFiles.forEach(file => {
    const key = parseTileKey(file.name);
    if (!key) { filesLoading--; return; }
    
    const reader = new FileReader();
    reader.onload = e => {
      const ab   = e.target.result;
      const arr  = new Int16Array(ab);
      const size = Math.sqrt(arr.length);
      if (size !== 1201 && size !== 3601) { 
        setStatus(`Invalid .hgt file: ${file.name}`, true);
        filesLoading--;
        return;
      }
      
      for (let i = 0; i < arr.length; i++) {
        const val = arr[i];
        arr[i] = ((val & 0xff) << 8) | ((val >> 8) & 0xff);
      }
      
      tiles[key] = { data: arr, size };
      renderTileTags();
      
      filesLoading--;
      if (filesLoading === 0) {
        saveTilesToStorage();
        setStatus(`All tiles loaded and saved (${Object.keys(tiles).length} total)`, false);
        drawTerrainMap();
      }
    };
    reader.readAsArrayBuffer(file);
  });
  fileInput.value = '';
}

function parseTileKey(name) {
  const m = name.match(/^([NS])(\d+)([EW])(\d+)\.hgt$/i);
  if (!m) return null;
  const lat = parseInt(m[2]) * (m[1].toUpperCase() === 'N' ? 1 : -1);
  const lng = parseInt(m[4]) * (m[3].toUpperCase() === 'E' ? 1 : -1);
  return tileKeyFromCoord(lat, lng);
}

function tileKeyFromCoord(lat, lng) {
  const floorLat = Math.floor(lat);
  const floorLng = Math.floor(lng);
  const ns = floorLat >= 0 ? 'N' : 'S';
  const ew = floorLng >= 0 ? 'E' : 'W';
  return `${ns}${Math.abs(floorLat).toString().padStart(2,'0')}${ew}${Math.abs(floorLng).toString().padStart(3,'0')}`;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   TERRAIN MAP DRAWING
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function drawTerrainMap() {
  const tileKeys = Object.keys(tiles);
  if (tileKeys.length === 0) return;

  let minLat = Infinity, maxLat = -Infinity, minLng = Infinity, maxLng = -Infinity;
  
  tileKeys.forEach(key => {
    const m = key.match(/^([NS])(\d+)([EW])(\d+)$/);
    if (!m) return;
    const lat = parseInt(m[2]) * (m[1] === 'N' ? 1 : -1);
    const lng = parseInt(m[4]) * (m[3] === 'E' ? 1 : -1);
    minLat = Math.min(minLat, lat);
    maxLat = Math.max(maxLat, lat + 1);
    minLng = Math.min(minLng, lng);
    maxLng = Math.max(maxLng, lng + 1);
  });

  const latRange = maxLat - minLat;
  const lngRange = maxLng - minLng;
  
  const dpr = window.devicePixelRatio || 1;
  const rect = mapCanvas.parentElement.getBoundingClientRect();
  const containerW = Math.max(Math.floor(rect.width), 600);
  const containerH = 400;
  
  const dataAspectRatio = lngRange / latRange;
  const containerAspectRatio = containerW / containerH;
  
  let W, H;
  if (dataAspectRatio > containerAspectRatio) {
    W = containerW;
    H = Math.floor(W / dataAspectRatio);
    if (H < containerH * 0.8) {
      H = containerH;
      W = Math.floor(H * dataAspectRatio);
    }
  } else {
    H = containerH;
    W = Math.floor(H * dataAspectRatio);
    if (W < containerW * 0.8) {
      W = containerW;
      H = Math.floor(W / dataAspectRatio);
    }
  }
  
  if (W <= 0 || H <= 0) return;
  
  mapCanvas.width = W * dpr;
  mapCanvas.height = H * dpr;
  mapCanvas.style.width = W + 'px';
  mapCanvas.style.height = H + 'px';
  mctx.scale(dpr, dpr);

  mctx.fillStyle = '#0a0c0f';
  mctx.fillRect(0, 0, W, H);

  // Apply zoom and pan transform
  mctx.save();
  mctx.translate(W/2, H/2);
  mctx.scale(mapZoom, mapZoom);
  mctx.translate(-W/2 + mapOffsetX, -H/2 + mapOffsetY);

  // Calculate visible area for sampling (accounting for zoom/pan)
  // After transform: point (x,y) in data space appears at screen position:
  // screenX = W/2 + (x - W/2 + mapOffsetX) * mapZoom
  // To find what's visible, we need to invert: what (x,y) appears at screen edges?
  // For left edge (screenX = 0): 0 = W/2 + (x - W/2 + mapOffsetX) * mapZoom
  // x = W/2 - mapOffsetX - W/(2*mapZoom)
  const visibleDataMinX = W/2 - mapOffsetX - W/(2*mapZoom);
  const visibleDataMaxX = W/2 - mapOffsetX + W/(2*mapZoom);
  const visibleDataMinY = H/2 - mapOffsetY - H/(2*mapZoom);
  const visibleDataMaxY = H/2 - mapOffsetY + H/(2*mapZoom);
  
  // Convert data space coordinates to lat/lng
  const viewMinLng = minLng + (visibleDataMinX / W) * lngRange;
  const viewMaxLng = minLng + (visibleDataMaxX / W) * lngRange;
  const viewMaxLat = minLat + (1 - visibleDataMinY / H) * latRange;
  const viewMinLat = minLat + (1 - visibleDataMaxY / H) * latRange;
  const viewLatRange = viewMaxLat - viewMinLat;
  const viewLngRange = viewMaxLng - viewMinLng;

  let minElev = Infinity, maxElev = -Infinity;

  // Sample terrain in visible area only - adjust density based on zoom level
  // Lower density when zoomed in (looking at small area), higher when zoomed out (looking at large area)
  const sampleDensity = mapZoom > 3 ? 100 : (mapZoom > 1.5 ? 150 : 200);
  const samples = [];
  
  for (let y = 0; y < sampleDensity; y++) {
    for (let x = 0; x < sampleDensity; x++) {
      const lat = viewMinLat + (viewLatRange * (sampleDensity - y) / sampleDensity);
      const lng = viewMinLng + (viewLngRange * x / sampleDensity);
      const elev = getElevation(lat, lng);
      if (elev !== null) {
        minElev = Math.min(minElev, elev);
        maxElev = Math.max(maxElev, elev);
        // Store canvas coordinates in data space (before transform)
        const canvasX = ((lng - minLng) / lngRange) * W;
        const canvasY = ((maxLat - lat) / latRange) * H;
        samples.push({ x: canvasX, y: canvasY, elev });
      }
    }
  }

  const elevRange = maxElev - minElev || 1;

  // Draw elevation as colored pixels - size based on zoom to fill screen
  const pixelSize = Math.max(Math.ceil(W / sampleDensity) * mapZoom, 1) + 1;
  samples.forEach(s => {
    const norm = (s.elev - minElev) / elevRange;
    const color = elevationColor(norm);
    mctx.fillStyle = color;
    mctx.fillRect(s.x, s.y, pixelSize, pixelSize);
  });

  // Draw grid for tile boundaries
  mctx.strokeStyle = 'rgba(78,159,255,0.3)';
  mctx.lineWidth = 1;
  for (let lat = Math.ceil(minLat); lat <= maxLat; lat++) {
    const py = H * (1 - (lat - minLat) / latRange);
    mctx.beginPath();
    mctx.moveTo(0, py);
    mctx.lineTo(W, py);
    mctx.stroke();
  }
  for (let lng = Math.ceil(minLng); lng <= maxLng; lng++) {
    const px = W * (lng - minLng) / lngRange;
    mctx.beginPath();
    mctx.moveTo(px, 0);
    mctx.lineTo(px, H);
    mctx.stroke();
  }

  // Helper function to convert lat/lng to canvas coordinates (data space)
  const toCanvasX = (lng) => W * (lng - minLng) / lngRange;
  const toCanvasY = (lat) => H * (1 - (lat - minLat) / latRange);

  // Draw radial sight lines if available
  if (radialData && radialData.length > 0 && observerLocation) {
    const cx = toCanvasX(observerLocation.lng);
    const cy = toCanvasY(observerLocation.lat);
    
    mctx.save();
    mctx.lineWidth = 2;
    
    radialData.forEach(ray => {
      // Draw segments based on LOS check at each point
      if (ray.losSegments && ray.losSegments.length > 0) {
        ray.losSegments.forEach(seg => {
          const startPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, seg.start);
          const endPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, seg.end);
          const sx = toCanvasX(startPoint.lng);
          const sy = toCanvasY(startPoint.lat);
          const ex = toCanvasX(endPoint.lng);
          const ey = toCanvasY(endPoint.lat);
          
          mctx.strokeStyle = seg.hasLOS ? 'rgba(78,255,160,0.6)' : 'rgba(255,92,92,0.6)';
          mctx.beginPath();
          mctx.moveTo(sx, sy);
          mctx.lineTo(ex, ey);
          mctx.stroke();
        });
      } else {
        // Fallback - draw entire line
        const endPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, ray.radius);
        const ex = toCanvasX(endPoint.lng);
        const ey = toCanvasY(endPoint.lat);
        
        mctx.strokeStyle = ray.visible ? 'rgba(78,255,160,0.6)' : 'rgba(255,92,92,0.6)';
        mctx.beginPath();
        mctx.moveTo(cx, cy);
        mctx.lineTo(ex, ey);
        mctx.stroke();
      }
    });
    mctx.restore();
  }

  // Draw A‚ÜíB line if target location exists
  if (observerLocation && targetLocation) {
    const x1 = toCanvasX(observerLocation.lng);
    const y1 = toCanvasY(observerLocation.lat);
    const x2 = toCanvasX(targetLocation.lng);
    const y2 = toCanvasY(targetLocation.lat);
    
    mctx.strokeStyle = '#4e9fff';
    mctx.lineWidth = 3 / mapZoom;
    mctx.setLineDash([8 / mapZoom, 4 / mapZoom]);
    mctx.beginPath();
    mctx.moveTo(x1, y1);
    mctx.lineTo(x2, y2);
    mctx.stroke();
    mctx.setLineDash([]);
    
    // Draw target marker - scale inversely with zoom
    mctx.beginPath();
    mctx.arc(x2, y2, 6 / mapZoom, 0, Math.PI*2);
    mctx.fillStyle = '#4e9fff';
    mctx.fill();
    mctx.strokeStyle = '#0a0c0f';
    mctx.lineWidth = 2 / mapZoom;
    mctx.stroke();
  }

  // Draw observer marker if set - scale inversely with zoom
  if (observerLocation) {
    const ox = toCanvasX(observerLocation.lng);
    const oy = toCanvasY(observerLocation.lat);
    
    mctx.beginPath();
    mctx.arc(ox, oy, 8 / mapZoom, 0, Math.PI*2);
    mctx.fillStyle = '#4effa0';
    mctx.fill();
    mctx.strokeStyle = '#0a0c0f';
    mctx.lineWidth = 2 / mapZoom;
    mctx.stroke();
  }
  
  // Draw site markers
  sites.forEach(site => {
    const sx = toCanvasX(site.lng);
    const sy = toCanvasY(site.lat);
    
    // Draw grey circle for site
    mctx.beginPath();
    mctx.arc(sx, sy, 6 / mapZoom, 0, Math.PI*2);
    mctx.fillStyle = '#808080';
    mctx.fill();
    mctx.strokeStyle = '#0a0c0f';
    mctx.lineWidth = 1.5 / mapZoom;
    mctx.stroke();
    
    // Draw tag label (keep in transformed space)
    const fontSize = 10 / mapZoom;
    mctx.font = `${fontSize}px "IBM Plex Mono"`;
    mctx.textAlign = 'center';
    mctx.textBaseline = 'bottom';
    
    // Background for tag
    const textMetrics = mctx.measureText(site.tag);
    const padding = 3 / mapZoom;
    const bgHeight = 12 / mapZoom;
    const bgY = sy - 10 / mapZoom - bgHeight;
    
    mctx.fillStyle = 'rgba(10, 12, 15, 0.8)';
    mctx.fillRect(
      sx - textMetrics.width / 2 - padding,
      bgY - padding,
      textMetrics.width + padding * 2,
      bgHeight + padding * 2
    );
    
    // Draw tag text
    mctx.fillStyle = '#c8d0dc';
    mctx.fillText(site.tag, sx, sy - 10 / mapZoom);
  });

  mctx.restore();
  
  // Draw elevation legend
  drawElevationLegend(mctx, W, H);

  mapCanvas._mapParams = { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom: mapZoom, offsetX: mapOffsetX, offsetY: mapOffsetY };

  document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';

  drawMinimap(minLat, maxLat, minLng, maxLng, W, H);
}

function drawElevationLegend(ctx, canvasW, canvasH) {
  const legendW = 120;
  const legendH = 340;
  const legendX = 20;
  const legendY = canvasH - legendH - 20;
  const barW = 30;
  const barX = legendX + 10;
  const barY = legendY + 30;
  const barH = legendH - 50;
  
  // Background
  ctx.fillStyle = 'rgba(10, 12, 15, 0.85)';
  ctx.fillRect(legendX, legendY, legendW, legendH);
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.strokeRect(legendX, legendY, legendW, legendH);
  
  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Elevation', legendX + legendW/2, legendY + 18);
  
  // Draw gradient bar (top to bottom = high to low)
  // Map 0-2900m range to gradient
  const steps = 100;
  const minElev = 0;
  const maxElev = 2900;
  const elevRange = maxElev - minElev;
  
  for (let i = 0; i < steps; i++) {
    const elev = maxElev - (i / steps) * elevRange; // Top = 2900, bottom = 0
    const normForColor = (elev + 100) / 3000; // Original normalization for color function
    const color = elevationColor(normForColor);
    ctx.fillStyle = color;
    ctx.fillRect(barX, barY + (i * barH / steps), barW, Math.ceil(barH / steps) + 1);
  }
  
  // Border around bar
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barW, barH);
  
  // Labels (every 100m from 0 to 2900m)
  ctx.fillStyle = '#fff';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  
  for (let elev = 2900; elev >= 0; elev -= 100) {
    const norm = (elev - minElev) / elevRange;
    const y = barY + barH * (1 - norm);
    
    // Tick mark
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(barX + barW, y);
    ctx.lineTo(barX + barW + 5, y);
    ctx.stroke();
    
    // Label
    ctx.fillStyle = '#fff';
    ctx.fillText(`${elev}m`, barX + barW + 8, y + 4);
  }
}

function elevationColor(norm) {
  if (norm < 0.25) {
    const t = norm / 0.25;
    return `rgb(${Math.round(30 + t * 70)}, ${Math.round(60 + t * 90)}, ${Math.round(90 + t * 60)})`;
  } else if (norm < 0.5) {
    const t = (norm - 0.25) / 0.25;
    return `rgb(${Math.round(100 + t * 55)}, ${Math.round(150 + t * 55)}, ${Math.round(150 - t * 50)})`;
  } else if (norm < 0.75) {
    const t = (norm - 0.5) / 0.25;
    return `rgb(${Math.round(155 + t * 70)}, ${Math.round(205 - t * 55)}, ${Math.round(100 - t * 50)})`;
  } else {
    const t = (norm - 0.75) / 0.25;
    return `rgb(${Math.round(225 + t * 30)}, ${Math.round(150 - t * 50)}, ${Math.round(50 - t * 20)})`;
  }
}

function drawMinimap(minLat, maxLat, minLng, maxLng, mainW, mainH) {
  const size = 120;
  minimapCanvas.width = size;
  minimapCanvas.height = size;
  
  miniCtx.fillStyle = '#0a0c0f';
  miniCtx.fillRect(0, 0, size, size);
  
  // Draw simplified terrain
  const latRange = maxLat - minLat;
  const lngRange = maxLng - minLng;
  
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const lng = minLng + (x / size) * lngRange;
      const lat = minLat + (1 - y / size) * latRange;
      const elev = getElevation(lat, lng);
      if (elev !== null) {
        const norm = (elev + 100) / 3000;
        const c = Math.round(norm * 180 + 40);
        miniCtx.fillStyle = `rgb(${c},${c},${c})`;
        miniCtx.fillRect(x, y, 1, 1);
      }
    }
  }
  
  // Draw viewport rectangle
  const zoom = mapZoom;
  const vw = size / zoom;
  const vh = size / zoom;
  const vx = size/2 - vw/2 - (mapOffsetX / mainW) * size * zoom;
  const vy = size/2 - vh/2 - (mapOffsetY / mainH) * size * zoom;
  
  miniCtx.strokeStyle = '#4e9fff';
  miniCtx.lineWidth = 2;
  miniCtx.strokeRect(vx, vy, vw, vh);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   MAP INTERACTIONS
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
// Click to set observer or target based on active tab
mapCanvas.addEventListener('click', e => {
  if (!mapCanvas._mapParams) return;
  
  // Don't set target if we were panning
  if (mapWasPanning) {
    mapWasPanning = false;
    return;
  }
  
  const activeTab = getActiveTab();
  
  const rect = mapCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  
  const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY } = mapCanvas._mapParams;
  
  // Account for any CSS scaling between canvas logical size and display size
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  const canvasX = mx * scaleX;
  const canvasY = my * scaleY;
  
  // Inverse transform to get data space coordinates
  // Forward: screenX = W/2 + (dataX - W/2 + offsetX) * zoom
  // Inverse: dataX = (screenX - W/2) / zoom + W/2 - offsetX
  const tx = (canvasX - W/2) / zoom + W/2 - offsetX;
  const ty = (canvasY - H/2) / zoom + H/2 - offsetY;
  
  if (tx >= 0 && tx <= W && ty >= 0 && ty <= H) {
    const lng = minLng + (tx / W) * lngRange;
    const lat = minLat + (1 - ty / H) * latRange;
    
    if (activeTab === 'observer') {
      // Set observer location
      observerLocation = { lat, lng };
      document.getElementById('obsLat').value = lat.toFixed(5);
      document.getElementById('obsLng').value = lng.toFixed(5);
      radialData = []; // Clear radial lines when observer moves
      
      setStatus('Observer location set to ' + lat.toFixed(5) + ', ' + lng.toFixed(5), false);
      drawTerrainMap();
    } else if (activeTab === 'ab') {
      // Set target location and generate profile
      targetLocation = { lat, lng };
      hoverLocation = null; // Clear hover when clicking
      document.getElementById('endLat').value = lat.toFixed(5);
      document.getElementById('endLng').value = lng.toFixed(5);
      
      setStatus('Target location set to ' + lat.toFixed(5) + ', ' + lng.toFixed(5), false);
      drawTerrainMap(); // Redraw to show updated blue line
      
      // Generate profile for this location
      if (observerLocation) {
        generateProfile();
      }
    }
  }
});

// Hover to show coordinates
mapCanvas.addEventListener('mousemove', e => {
  if (mapIsPanning || !mapCanvas._mapParams) return;
  
  const rect = mapCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  
  const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H, zoom, offsetX, offsetY } = mapCanvas._mapParams;
  
  // Account for any CSS scaling between canvas logical size and display size
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  const canvasX = mx * scaleX;
  const canvasY = my * scaleY;
  
  // Inverse transform to get data space coordinates
  const tx = (canvasX - W/2) / zoom + W/2 - offsetX;
  const ty = (canvasY - H/2) / zoom + H/2 - offsetY;
  
  if (tx < 0 || tx > W || ty < 0 || ty > H) {
    mapHoverInfo.classList.remove('visible');
    return;
  }
  
  const lng = minLng + (tx / W) * lngRange;
  const lat = minLat + (1 - ty / H) * latRange;
  const elev = getElevation(lat, lng);
  
  // Check if hovering over a site
  let hoveredSite = null;
  for (const site of sites) {
    const siteCanvasX = W * (site.lng - minLng) / lngRange;
    const siteCanvasY = H * (1 - (site.lat - minLat) / latRange);
    
    // Transform to screen coordinates
    const siteTx = (siteCanvasX - W/2 + offsetX) * zoom + W/2;
    const siteTy = (siteCanvasY - H/2 + offsetY) * zoom + H/2;
    
    // Check distance in screen space
    const dist = Math.sqrt((canvasX - siteTx) ** 2 + (canvasY - siteTy) ** 2);
    const hoverRadius = 15; // pixels
    
    if (dist < hoverRadius) {
      hoveredSite = site;
      break;
    }
  }
  
  if (hoveredSite) {
    // Show site info with name on fourth line
    const siteElev = getElevation(hoveredSite.lat, hoveredSite.lng);
    document.getElementById('hoverLat').textContent = hoveredSite.lat.toFixed(5) + '¬∞';
    document.getElementById('hoverLng').textContent = hoveredSite.lng.toFixed(5) + '¬∞';
    document.getElementById('hoverElev').textContent = siteElev !== null ? Math.round(siteElev) + ' m' : '‚Äî';
    document.getElementById('hoverSite').textContent = hoveredSite.name;
    document.getElementById('hoverSiteDiv').style.display = 'block';
    mapHoverInfo.style.left = (mx + 14) + 'px';
    mapHoverInfo.style.top = (my - 80) + 'px';
    mapHoverInfo.classList.add('visible');
    return;
  }
  
  if (elev !== null) {
    document.getElementById('hoverLat').textContent = lat.toFixed(5) + '¬∞';
    document.getElementById('hoverLng').textContent = lng.toFixed(5) + '¬∞';
    document.getElementById('hoverElev').textContent = Math.round(elev) + ' m';
    document.getElementById('hoverSiteDiv').style.display = 'none';
    mapHoverInfo.style.left = (mx + 14) + 'px';
    mapHoverInfo.style.top = (my - 60) + 'px';
    mapHoverInfo.classList.add('visible');
    
    // On A‚ÜíB tab, generate profile for hover location
    const activeTab = getActiveTab();
    if (activeTab === 'ab' && observerLocation) {
      hoverLocation = { lat, lng };
      
      // Generate profile for hover location
      const sLat = observerLocation.lat;
      const sLng = observerLocation.lng;
      const N = parseInt(document.getElementById('sampleCount').value);
      const dist = haversine(sLat, sLng, lat, lng);
      const hoverProfileData = [];
      
      for (let i = 0; i <= N; i++) {
        const t = i / N;
        const pt = interpolateLine(sLat, sLng, lat, lng, t);
        const elev = getElevation(pt.lat, pt.lng);
        const d = dist * t;
        hoverProfileData.push({ dist: d, elev: elev !== null ? elev : null });
      }
      
      if (!hoverProfileData.every(p => p.elev === null)) {
        const startElev = hoverProfileData.find(p => p.elev !== null)?.elev ?? 0;
        const endElev = hoverProfileData[hoverProfileData.length - 1]?.elev ?? 0;
        const obsH = parseFloat(document.getElementById('obsHeight')?.value || 0);
        const treeH = parseFloat(document.getElementById('treeHeight')?.value || 5);
        const hoverLOS = checkLOS(sLat, sLng, startElev + obsH, lat, lng, N, treeH, endElev);
        
        // Update profile display with hover data
        profileData = hoverProfileData;
        cachedLOS = hoverLOS;
        updateProfileStats(dist, hoverLOS);
        drawProfile(hoverLOS);
        
        // Calculate distance for profile cursor
        hoverDistance = haversine(observerLocation.lat, observerLocation.lng, lat, lng);
      }
    } else {
      hoverLocation = null;
      hoverDistance = null;
    }
  } else {
    mapHoverInfo.classList.remove('visible');
    hoverDistance = null;
  }
});

mapCanvas.addEventListener('mouseleave', () => {
  mapHoverInfo.classList.remove('visible');
  hoverDistance = null;
  hoverLocation = null;
  
  // Revert to blue line profile on A‚ÜíB tab
  const activeTab = getActiveTab();
  if (activeTab === 'ab' && blueLineProfileData.length > 0) {
    profileData = blueLineProfileData;
    cachedLOS = blueLineLOS;
    if (observerLocation && targetLocation) {
      const dist = haversine(observerLocation.lat, observerLocation.lng, targetLocation.lat, targetLocation.lng);
      updateProfileStats(dist, blueLineLOS);
    }
    drawProfile(blueLineLOS);
  }
});

// Pan
mapCanvas.addEventListener('mousedown', e => {
  mapIsPanning = true;
  mapWasPanning = false;
  mapLastX = e.clientX;
  mapLastY = e.clientY;
  mapCanvas.classList.add('panning');
  
  // Revert to blue line when panning
  hoverLocation = null;
  const activeTab = getActiveTab();
  if (activeTab === 'ab' && blueLineProfileData.length > 0) {
    profileData = blueLineProfileData;
    cachedLOS = blueLineLOS;
    if (observerLocation && targetLocation) {
      const dist = haversine(observerLocation.lat, observerLocation.lng, targetLocation.lat, targetLocation.lng);
      updateProfileStats(dist, blueLineLOS);
    }
    drawProfile(blueLineLOS);
  }
});

mapCanvas.addEventListener('mousemove', e => {
  if (!mapIsPanning) return;
  mapWasPanning = true; // Mark that we actually moved while panning
  const dx = e.clientX - mapLastX;
  const dy = e.clientY - mapLastY;
  mapOffsetX += dx / mapZoom;
  mapOffsetY += dy / mapZoom;
  mapLastX = e.clientX;
  mapLastY = e.clientY;
  
  // Debounce drawing during pan
  clearTimeout(window._panDrawTimer);
  window._panDrawTimer = setTimeout(() => drawTerrainMap(), 16); // ~60fps
});

mapCanvas.addEventListener('mouseup', () => {
  mapIsPanning = false;
  mapCanvas.classList.remove('panning');
});

mapCanvas.addEventListener('mouseleave', () => {
  mapIsPanning = false;
  mapCanvas.classList.remove('panning');
});

// Zoom
mapCanvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  mapZoom *= zoomFactor;
  mapZoom = Math.max(0.5, Math.min(10, mapZoom));
  document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';
  
  // Debounce drawing during zoom
  clearTimeout(window._zoomDrawTimer);
  window._zoomDrawTimer = setTimeout(() => drawTerrainMap(), 16); // ~60fps
});

// Minimap navigation
minimapCanvas.addEventListener('click', e => {
  const rect = minimapCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;
  
  if (!mapCanvas._mapParams) return;
  const { W, H } = mapCanvas._mapParams;
  
  const targetX = (x - 0.5) * W;
  const targetY = (y - 0.5) * H;
  
  mapOffsetX = -targetX;
  mapOffsetY = -targetY;
  drawTerrainMap();
});

document.getElementById('btnResetZoom')?.addEventListener('click', () => {
  mapZoom = 1;
  mapOffsetX = 0;
  mapOffsetY = 0;
  drawTerrainMap();
});

document.getElementById('btnSaveTiles')?.addEventListener('click', saveTilesToStorage);
document.getElementById('btnLoadTiles')?.addEventListener('click', loadTilesFromStorage);

// Import page dropzone and buttons
if (dropzone2 && fileInput2) {
  dropzone2.addEventListener('click', () => fileInput2.click());
  dropzone2.addEventListener('dragover', e => { e.preventDefault(); dropzone2.classList.add('dragover'); });
  dropzone2.addEventListener('dragleave', e => { e.preventDefault(); dropzone2.classList.remove('dragover'); });
  dropzone2.addEventListener('drop', e => { e.preventDefault(); dropzone2.classList.remove('dragover'); loadFiles(e.dataTransfer.files); });
  fileInput2.addEventListener('change', e => loadFiles(e.target.files));
}

document.getElementById('btnSaveTiles2')?.addEventListener('click', saveTilesToStorage);
document.getElementById('btnLoadTiles2')?.addEventListener('click', () => {
  loadTilesFromStorage();
  if (typeof renderTileTags2 === 'function') renderTileTags2();
});

function renderTileTags2() {
  // Render for import page
  if (tileList2) {
    tileList2.innerHTML = '';
    Object.keys(tiles).forEach(key => {
      const t   = tiles[key];
      const tag = document.createElement('div');
      tag.className = 'tile-tag';
      tag.innerHTML = `<span class="tag-name">${key}</span><span class="tag-res">${t.size === 1201 ? '3‚Ä≥' : '1‚Ä≥'}</span><span class="tag-remove" data-key="${key}">‚úï</span>`;
      tileList2.appendChild(tag);
    });
    tileList2.querySelectorAll('.tag-remove').forEach(el => {
      el.addEventListener('click', () => { 
        delete tiles[el.dataset.key]; 
        renderTileTags(); 
        renderTileTags2();
        drawTerrainMap();
      });
    });
  }
}

function renderTileTags() {
  // Render for terrain page
  if (tileList) {
    tileList.innerHTML = '';
    Object.keys(tiles).forEach(key => {
      const t   = tiles[key];
      const tag = document.createElement('div');
      tag.className = 'tile-tag';
      tag.innerHTML = `<span class="tag-name">${key}</span><span class="tag-res">${t.size === 1201 ? '3‚Ä≥' : '1‚Ä≥'}</span><span class="tag-remove" data-key="${key}">‚úï</span>`;
      tileList.appendChild(tag);
    });
    tileList.querySelectorAll('.tag-remove').forEach(el => {
      el.addEventListener('click', () => { 
        delete tiles[el.dataset.key]; 
        renderTileTags(); 
        renderTileTags2();
        drawTerrainMap();
      });
    });
  }
  if (typeof renderTileTags2 === 'function') renderTileTags2();
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   ELEVATION LOOKUP
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function getElevation(lat, lng) {
  const key = tileKeyFromCoord(lat, lng);
  const tile = tiles[key];
  if (!tile) return null;

  const { data, size } = tile;
  const floorLat = Math.floor(lat);
  const floorLng = Math.floor(lng);

  const rowFrac = (lat - floorLat);
  const colFrac = (lng - floorLng);

  const row = (1 - rowFrac) * (size - 1);
  const col = colFrac * (size - 1);

  const r0 = Math.floor(row), r1 = Math.min(r0 + 1, size - 1);
  const c0 = Math.floor(col), c1 = Math.min(c0 + 1, size - 1);

  const e00 = data[r0 * size + c0];
  const e01 = data[r0 * size + c1];
  const e10 = data[r1 * size + c0];
  const e11 = data[r1 * size + c1];

  if (e00 === -32768 || e01 === -32768 || e10 === -32768 || e11 === -32768) return null;

  const tr = row - r0;
  const tc = col - c0;
  const top = e00 * (1 - tc) + e01 * tc;
  const bot = e10 * (1 - tc) + e11 * tc;
  return top * (1 - tr) + bot * tr;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   GEO HELPERS
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
const EARTH_R = 6371.0;

function haversine(lat1, lng1, lat2, lng2) {
  const dLat = (lat2 - lat1) * DEG2RAD;
  const dLng = (lng2 - lng1) * DEG2RAD;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*DEG2RAD)*Math.cos(lat2*DEG2RAD)*Math.sin(dLng/2)**2;
  return EARTH_R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function interpolateLine(lat1, lng1, lat2, lng2, t) {
  return { lat: lat1+(lat2-lat1)*t, lng: lng1+(lng2-lng1)*t };
}

function destPoint(lat, lng, bearingDeg, distKm) {
  const lat1 = lat * DEG2RAD;
  const lng1 = lng * DEG2RAD;
  const brng = bearingDeg * DEG2RAD;
  const d    = distKm / EARTH_R;

  const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(brng));
  const lng2 = lng1 + Math.atan2(Math.sin(brng)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
  return { lat: lat2 * RAD2DEG, lng: lng2 * RAD2DEG };
}

function bearing(lat1, lng1, lat2, lng2) {
  const dLng = (lng2 - lng1) * DEG2RAD;
  const y = Math.sin(dLng) * Math.cos(lat2 * DEG2RAD);
  const x = Math.cos(lat1 * DEG2RAD) * Math.sin(lat2 * DEG2RAD) - 
            Math.sin(lat1 * DEG2RAD) * Math.cos(lat2 * DEG2RAD) * Math.cos(dLng);
  const brng = Math.atan2(y, x) * RAD2DEG;
  return (brng + 360) % 360; // Normalize to 0-360
}

function distanceToLineSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const lengthSquared = dx * dx + dy * dy;
  
  if (lengthSquared === 0) {
    const dpx = px - x1;
    const dpy = py - y1;
    return Math.sqrt(dpx * dpx + dpy * dpy);
  }
  
  let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
  t = Math.max(0, Math.min(1, t));
  
  const closestX = x1 + t * dx;
  const closestY = y1 + t * dy;
  
  const dpx = px - closestX;
  const dpy = py - closestY;
  return Math.sqrt(dpx * dpx + dpy * dpy);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   LINE OF SIGHT CHECK
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function checkLOS(lat1, lng1, elev1, lat2, lng2, samples, treeH = 0, elev2 = null) {
  const dist = haversine(lat1, lng1, lat2, lng2);
  if (elev2 === null) {
    elev2 = getElevation(lat2, lng2) || 0;
  }
  
  let visible = true;
  let visibleDist = dist;
  let blockElev = null;
  let blockDist = null;
  const blockages = []; // Array of obstruction entry/exit points
  let wasBlocked = false; // Track previous sample state

  for (let i = 1; i < samples; i++) {
    const t = i / samples;
    const pt = interpolateLine(lat1, lng1, lat2, lng2, t);
    const terrainElev = getElevation(pt.lat, pt.lng);
    if (terrainElev === null) continue;
    
    const effectiveElev = terrainElev + treeH;
    const d = dist * t;
    const lineElev = elev1 + (elev2 - elev1) * t;
    
    const isBlocked = effectiveElev > lineElev;
    
    // Detect transitions: entering or exiting obstruction
    if (isBlocked && !wasBlocked) {
      // Entering obstruction
      blockages.push({ dist: d, elev: effectiveElev, type: 'entry' });
      visible = false;
      if (blockElev === null) {
        blockElev = effectiveElev;
        blockDist = d;
        visibleDist = d;
      }
    } else if (!isBlocked && wasBlocked) {
      // Exiting obstruction - mark previous point as exit
      if (blockages.length > 0) {
        const prevT = (i - 1) / samples;
        const prevPt = interpolateLine(lat1, lng1, lat2, lng2, prevT);
        const prevTerrainElev = getElevation(prevPt.lat, prevPt.lng);
        if (prevTerrainElev !== null) {
          blockages.push({ dist: dist * prevT, elev: prevTerrainElev + treeH, type: 'exit' });
        }
      }
    }
    
    wasBlocked = isBlocked;
  }

  return { visible, visibleDist, blockElev, blockDist, blockages };
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   GENERATE A‚ÜíB PROFILE
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
document.getElementById('btnGenerateAB')?.addEventListener('click', generateProfile);

function generateProfile() {
  const sLat = parseFloat(document.getElementById('obsLat').value);
  const sLng = parseFloat(document.getElementById('obsLng').value);
  const eLat = parseFloat(document.getElementById('endLat').value);
  const eLng = parseFloat(document.getElementById('endLng').value);

  if ([sLat, sLng, eLat, eLng].some(isNaN)) { 
    setStatus('Observer and target coordinates are required.', true); 
    return; 
  }

  observerLocation = { lat: sLat, lng: sLng };
  targetLocation = { lat: eLat, lng: eLng };

  const N    = parseInt(document.getElementById('sampleCount').value);
  const dist = haversine(sLat, sLng, eLat, eLng);
  profileData = [];

  for (let i = 0; i <= N; i++) {
    const t    = i / N;
    const pt   = interpolateLine(sLat, sLng, eLat, eLng, t);
    const elev = getElevation(pt.lat, pt.lng);
    const d    = dist * t;
    profileData.push({ dist: d, elev: elev !== null ? elev : null });
  }

  if (profileData.every(p => p.elev === null)) { 
    setStatus('No elevation data ‚Äî check tiles are loaded.', true); 
    return; 
  }

  const startElev = profileData.find(p => p.elev !== null)?.elev ?? 0;
  const endElev = profileData[profileData.length - 1]?.elev ?? 0;
  const obsH = parseFloat(document.getElementById('obsHeight')?.value || 0);
  const treeH = parseFloat(document.getElementById('treeHeight')?.value || 5);
  
  const losResult = checkLOS(sLat, sLng, startElev + obsH, eLat, eLng, N, treeH, endElev);

  setStatus(`Profile generated ¬∑ ${N+1} samples ¬∑ ${dist.toFixed(2)} km`, false);

  cachedLOS = losResult;
  blueLineProfileData = [...profileData]; // Store blue line profile
  blueLineLOS = losResult;                 // Store blue line LOS
  updateProfileStats(dist, losResult);
  drawProfile(losResult);
  drawTerrainMap();
  
  // Show profile panels
  document.getElementById('profilePanel').classList.add('visible');
  document.getElementById('profileOptionsPanel').classList.add('visible');
}

function updateProfileStats(dist, losResult) {
  const validElevs = profileData.filter(p => p.elev !== null).map(p => p.elev);
  const maxElev = Math.max(...validElevs);
  const minElev = Math.min(...validElevs);
  const startElev = profileData.find(p => p.elev !== null)?.elev;
  const endElev = profileData[profileData.length - 1]?.elev;

  document.getElementById('statDist').innerHTML = `${dist.toFixed(2)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">km</span>`;
  document.getElementById('statMax').innerHTML = `${Math.round(maxElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>`;
  document.getElementById('statMin').innerHTML = `${Math.round(minElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>`;
  document.getElementById('statStart').innerHTML = startElev ? `${Math.round(startElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>` : '‚Äî';
  document.getElementById('statEnd').innerHTML = endElev ? `${Math.round(endElev)}<span style="font-size:0.7em;color:var(--text-dim);margin-left:3px;">m</span>` : '‚Äî';
  document.getElementById('statLOS').innerHTML = losResult.visible 
    ? '<span style="color:var(--accent-green)">VISIBLE</span>' 
    : '<span style="color:var(--danger)">BLOCKED</span>';
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   HELPER FUNCTIONS FOR PROFILE DRAWING
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function niceStep(raw) {
  const mag  = Math.pow(10, Math.floor(Math.log10(raw)));
  const norm = raw / mag;
  if (norm < 1.5) return mag;
  if (norm < 3.5) return 2*mag;
  if (norm < 7.5) return 5*mag;
  return 10*mag;
}

function calculateOptimalTowerHeights(profileData, treeHeight = 5) {
  // Calculate optimal tower heights at start and end to minimize TOTAL height (start + end)
  const n = profileData.length;
  if (n < 2) return { startHeight: 0, endHeight: 0, totalHeight: 0 };
  
  const startElev = profileData[0].elev || 0;
  const endElev = profileData[n - 1].elev || 0;
  const totalDist = profileData[n - 1].dist;
  
  let minTotalHeight = Infinity;
  let bestStart = 0, bestEnd = 0;
  
  // Use a coarser step size for faster search
  const step = 1.0; // 1 meter steps instead of 0.5
  
  // Binary search / optimization for minimum total height
  // For each possible total height, find if there's a valid split
  // Search up to 300m to detect when solution exceeds practical limits
  for (let totalH = 0; totalH <= 300; totalH += step) {
    // Try different splits of this total height
    for (let startH = 0; startH <= totalH; startH += step) {
      const endH = totalH - startH;
      
      // Check if this combination gives LOS
      const p1Elev = startElev + startH;
      const p2Elev = endElev + endH;
      let clearLOS = true;
      
      for (let i = 1; i < n - 1; i++) {
        if (profileData[i].elev === null) continue;
        
        const dist = profileData[i].dist;
        const terrainElev = profileData[i].elev + treeHeight;
        
        // Height of LOS line at this point
        const t = dist / totalDist;
        const losElev = p1Elev + (p2Elev - p1Elev) * t;
        
        if (terrainElev > losElev) {
          clearLOS = false;
          break;
        }
      }
      
      if (clearLOS) {
        if (totalH < minTotalHeight) {
          minTotalHeight = totalH;
          bestStart = startH;
          bestEnd = endH;
        }
        break; // Found a valid split for this total, no need to try more
      }
    }
    
    // Early exit if we found a solution
    if (minTotalHeight < Infinity) {
      break;
    }
  }
  
  return { startHeight: bestStart, endHeight: bestEnd, totalHeight: minTotalHeight };
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DRAW PROFILE
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function drawProfile(los) {
  const dpr  = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const W    = rect.width > 0 ? rect.width : 1060;
  const H    = rect.height > 0 ? rect.height : 320;
  
  // Use full container dimensions
  canvas.style.width  = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width  = W * dpr;
  canvas.height = H * dpr;
  
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  ctx.scale(dpr, dpr);

  // Get actual canvas dimensions
  const actualW = W;
  const actualH = H;
  
  const validPoints = profileData.filter(p => p.elev !== null);
  
  const pad = { top: 30, right: 28, bottom: 40, left: 62 };
  const pw  = actualW - pad.left - pad.right;
  const ph  = actualH - pad.top  - pad.bottom;

  // Reuse validPoints from aspect ratio calculation if available, otherwise recalculate
  let maxDist, minElev, maxElev, elevRange;
  if (validPoints.length > 0) {
    maxDist  = profileData[profileData.length-1].dist;
    minElev  = Math.min(...validPoints.map(p => p.elev));
    maxElev  = Math.max(...validPoints.map(p => p.elev));
    elevRange= maxElev - minElev || 1;
  } else {
    const vp = profileData.filter(p => p.elev !== null);
    maxDist  = profileData[profileData.length-1]?.dist || 0;
    minElev  = vp.length > 0 ? Math.min(...vp.map(p => p.elev)) : 0;
    maxElev  = vp.length > 0 ? Math.max(...vp.map(p => p.elev)) : 0;
    elevRange= maxElev - minElev || 1;
  }
  const padElev  = elevRange * 0.06;

  const toX = d => pad.left + (d / maxDist) * pw;
  const toY = e => pad.top  + ph - ((e - minElev + padElev) / (elevRange + padElev*2)) * ph;

  ctx.clearRect(0, 0, actualW, actualH);

  /* grid */
  ctx.save();
  ctx.font = '10px "IBM Plex Mono", monospace';
  ctx.fillStyle = '#606878';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  const elevStep  = niceStep(elevRange / 4);
  const elevStart = Math.floor((minElev - padElev) / elevStep) * elevStep;
  for (let e = elevStart; e <= maxElev + padElev; e += elevStep) {
    const y = toY(e);
    if (y < pad.top || y > actualH-pad.bottom) continue;
    ctx.strokeStyle = (e%(elevStep*2)===0) ? 'rgba(78,159,255,0.15)' : 'rgba(78,159,255,0.07)';
    ctx.lineWidth = 0.7;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(actualW-pad.right, y); ctx.stroke();
    ctx.fillText(Math.round(e)+' m', pad.left-8, y);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  const distStep = niceStep(maxDist / 5);
  for (let d = 0; d <= maxDist; d += distStep) {
    const x = toX(d);
    ctx.strokeStyle = 'rgba(78,159,255,0.07)';
    ctx.lineWidth = 0.7;
    ctx.beginPath(); ctx.moveTo(x, pad.top); ctx.lineTo(x, actualH-pad.bottom); ctx.stroke();
    ctx.fillStyle = '#606878';
    ctx.fillText(d.toFixed(1)+' km', x, actualH-pad.bottom+6);
  }
  ctx.restore();

  /* filled area */
  const grad = ctx.createLinearGradient(0, pad.top, 0, actualH-pad.bottom);
  grad.addColorStop(0, 'rgba(78,159,255,0.40)');
  grad.addColorStop(1, 'rgba(78,159,255,0.02)');

  ctx.beginPath();
  let started = false;
  profileData.forEach(p => {
    if (p.elev === null) { started = false; return; }
    const x = toX(p.dist), y = toY(p.elev);
    if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
  });
  const lastValid  = [...profileData].reverse().find(p => p.elev !== null);
  const firstValid = profileData.find(p => p.elev !== null);
  if (lastValid && firstValid) {
    ctx.lineTo(toX(lastValid.dist), actualH-pad.bottom);
    ctx.lineTo(toX(firstValid.dist), actualH-pad.bottom);
    ctx.closePath();
  }
  ctx.fillStyle = grad;
  ctx.fill();

  /* terrain stroke */
  ctx.beginPath();
  started = false;
  profileData.forEach(p => {
    if (p.elev === null) { started = false; return; }
    const x = toX(p.dist), y = toY(p.elev);
    if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
  });
  ctx.strokeStyle = '#4e9fff';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.stroke();

  /* ‚îÄ‚îÄ‚îÄ TOWER HEIGHT LINES ‚îÄ‚îÄ‚îÄ */
  const showLOS = document.getElementById('showLOS')?.checked ?? true;
  const showUserTowers = document.getElementById('showUserTowers')?.checked;
  const showMinTowers = document.getElementById('showMinTowers')?.checked;
  const showOptimalTowers = document.getElementById('showOptimalTowers')?.checked;
  const treeHeight = parseFloat(document.getElementById('treeHeight')?.value || 5);
  
  // Draw tree height offset as filled area
  if (treeHeight > 0) {
    ctx.save();
    const treeGrad = ctx.createLinearGradient(0, pad.top, 0, H-pad.bottom);
    treeGrad.addColorStop(0, 'rgba(34,139,34,0.2)');
    treeGrad.addColorStop(1, 'rgba(34,139,34,0.05)');
    
    ctx.beginPath();
    let started = false;
    profileData.forEach(p => {
      if (p.elev === null) { started = false; return; }
      const x = toX(p.dist), y = toY(p.elev + treeHeight);
      if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    // Close the path along terrain
    const reversed = [...profileData].reverse();
    reversed.forEach(p => {
      if (p.elev === null) return;
      const x = toX(p.dist), y = toY(p.elev);
      ctx.lineTo(x,y);
    });
    ctx.closePath();
    ctx.fillStyle = treeGrad;
    ctx.fill();
    
    // Draw tree height line
    ctx.strokeStyle = 'rgba(34,139,34,0.6)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 2]);
    ctx.beginPath();
    started = false;
    profileData.forEach(p => {
      if (p.elev === null) { started = false; return; }
      const x = toX(p.dist), y = toY(p.elev + treeHeight);
      if (!started) { ctx.moveTo(x,y); started = true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
    ctx.restore();
  }

  // Draw user-defined tower heights
  if (showUserTowers && firstValid && lastValid) {
    const startTowerH = parseFloat(document.getElementById('startTowerHeight')?.value || 10);
    const endTowerH = parseFloat(document.getElementById('endTowerHeight')?.value || 10);
    
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startTowerH);
    const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev + endTowerH);

    ctx.save();
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = '#ffb340';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
    
    // Draw tower verticals
    ctx.save();
    ctx.strokeStyle = '#ffb340';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
    ctx.lineTo(x1, y1);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }

  // Draw minimum tower heights: line from start tower to end point, and end tower to start point
  if (showMinTowers && firstValid && lastValid) {
    // Calculate height needed at start to see end at ground level (accounting for trees)
    let startHeightNeeded = 0;
    const totalDist = lastValid.dist - firstValid.dist;
    
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeHeight; // Terrain + trees
      
      // Line of sight from start tower (height unknown) to end ground level
      // At point i, the LOS elevation would be: startElev + h + (endElev - (startElev + h)) * progress
      // Where progress = (iDist - firstValid.dist) / totalDist
      // Simplifying: startElev + h * (1 - progress) + endElev * progress
      const progress = (iDist - firstValid.dist) / totalDist;
      
      // We need: iElev <= startElev + h * (1 - progress) + endElev * progress
      // Solving for h: h >= (iElev - startElev - endElev * progress) / (1 - progress)
      if (progress < 1) {
        const requiredH = (iElev - firstValid.elev - lastValid.elev * progress) / (1 - progress);
        startHeightNeeded = Math.max(startHeightNeeded, requiredH);
      }
    }
    startHeightNeeded = Math.max(0, startHeightNeeded);

    // Calculate height needed at end to see start at ground level (accounting for trees)
    let endHeightNeeded = 0;
    
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeHeight; // Terrain + trees
      
      // Line of sight from end tower (height unknown) to start ground level
      // At point i, the LOS elevation would be: endElev + h + (startElev - (endElev + h)) * reverseProgress
      // Where reverseProgress = (lastValid.dist - iDist) / totalDist
      const reverseProgress = (lastValid.dist - iDist) / totalDist;
      
      // We need: iElev <= endElev + h * (1 - reverseProgress) + startElev * reverseProgress
      // Solving for h: h >= (iElev - endElev - startElev * reverseProgress) / (1 - reverseProgress)
      if (reverseProgress < 1) {
        const requiredH = (iElev - lastValid.elev - firstValid.elev * reverseProgress) / (1 - reverseProgress);
        endHeightNeeded = Math.max(endHeightNeeded, requiredH);
      }
    }
    endHeightNeeded = Math.max(0, endHeightNeeded);

    ctx.save();
    
    // Line from start tower to end
    if (startHeightNeeded > 0) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startHeightNeeded);
      const x2 = toX(lastValid.dist), y2 = toY(lastValid.elev);
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = 'rgba(255,179,64,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Tower vertical
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255,179,64,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      
      // Label
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = 'rgba(255,179,64,1)';
      ctx.textAlign = 'left';
      ctx.fillText(`${startHeightNeeded.toFixed(1)}m`, x1 + 5, y1);
    }
    
    // Line from end tower to start
    if (endHeightNeeded > 0) {
      const x1 = toX(lastValid.dist), y1 = toY(lastValid.elev + endHeightNeeded);
      const x2 = toX(firstValid.dist), y2 = toY(firstValid.elev);
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = 'rgba(255,140,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      // Tower vertical
      ctx.setLineDash([]);
      ctx.strokeStyle = 'rgba(255,140,100,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      
      // Label
      ctx.font = '10px "IBM Plex Mono", monospace';
      ctx.fillStyle = 'rgba(255,140,100,1)';
      ctx.textAlign = 'right';
      ctx.fillText(`${endHeightNeeded.toFixed(1)}m`, x1 - 5, y1);
    }
    
    ctx.restore();
  }

  // Draw optimal combined tower heights
  if (showOptimalTowers && firstValid && lastValid) {
    const optimal = calculateOptimalTowerHeights(profileData, treeHeight);
    
    if (optimal && optimal.totalHeight < Infinity) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + optimal.startHeight);
      const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev + optimal.endHeight);

      ctx.save();
      ctx.setLineDash([8, 3]);
      ctx.strokeStyle = '#4effa0';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
      
      // Draw tower verticals
      ctx.save();
      ctx.strokeStyle = '#4effa0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(toX(firstValid.dist), toY(firstValid.elev));
      ctx.lineTo(x1, y1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(toX(lastValid.dist), toY(lastValid.elev));
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
      
      // Add label
      ctx.save();
      ctx.font = '11px "IBM Plex Mono", monospace';
      ctx.fillStyle = '#4effa0';
      ctx.textAlign = 'center';
      ctx.fillText(`Optimal: ${optimal.startHeight.toFixed(1)}m + ${optimal.endHeight.toFixed(1)}m`, (x1+x2)/2, Math.min(y1,y2) - 10);
      ctx.restore();
    } else {
      // Show warning if no solution found within limit
      ctx.save();
      ctx.fillStyle = '#ffaa00';
      ctx.font = 'bold 16px sans-serif';
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 3;
      const warningText = '‚ö† Optimal tower height exceeds 300m limit';
      ctx.strokeText(warningText, pad.left + 10, pad.top + 40);
      ctx.fillText(warningText, pad.left + 10, pad.top + 40);
      ctx.restore();
    }
  }

  /* ‚îÄ‚îÄ‚îÄ LINE OF SIGHT between start and end ‚îÄ‚îÄ‚îÄ */
  if (showLOS && firstValid && lastValid) {
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev);
    const x2 = toX(lastValid.dist),  y2 = toY(lastValid.elev);

    // dashed style, colour depends on visibility
    ctx.save();
    ctx.setLineDash([8, 5]);
    ctx.lineDashOffset = 0;

    if (los && los.visible) {
      ctx.strokeStyle = 'rgba(78,255,160,0.7)';
    } else {
      ctx.strokeStyle = 'rgba(255,92,92,0.7)';
    }
    ctx.lineWidth = 1.8;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();

    // Mark obstruction entry/exit points
    if (los && !los.visible && los.blockages && los.blockages.length > 0) {
      const startTowerH = parseFloat(document.getElementById('startTowerHeight')?.value || 0);
      const endTowerH = parseFloat(document.getElementById('endTowerHeight')?.value || 0);
      const treeH = parseFloat(document.getElementById('treeHeight')?.value || 0);
      
      const startTerrainElev = firstValid ? firstValid.elev : 0;
      const endTerrainElev = lastValid ? lastValid.elev : 0;
      
      const startWithTower = startTerrainElev + startTowerH;
      const endWithTower = endTerrainElev + endTowerH;
      
      ctx.save();
      ctx.strokeStyle = var_danger();
      ctx.lineWidth = 2;
      
      los.blockages.forEach(block => {
        // Skip if this blockage is at the start and observer tower clears it
        if (block.dist < 0.01 && startWithTower >= block.elev) return;
        
        // Skip if this blockage is at the end and remote tower clears it
        const distFromEnd = Math.abs(block.dist - (lastValid ? lastValid.dist : 0));
        if (distFromEnd < 0.01 && endWithTower >= block.elev) return;
        
        // Calculate position on LOS line (which is drawn at terrain level) at this distance
        const bx = toX(block.dist);
        const t = (bx - x1) / (x2 - x1);
        const by = y1 + (y2 - y1) * t;
        
        ctx.beginPath();
        ctx.moveTo(bx-6, by-6); ctx.lineTo(bx+6, by+6);
        ctx.moveTo(bx+6, by-6); ctx.lineTo(bx-6, by+6);
        ctx.stroke();
      });
      
      ctx.restore();
    }
  }
  
  // Helper function to find obstructions for any line (entry/exit points only)
  function findLineObstructions(x1, y1, x2, y2) {
    const obstructions = [];
    const treeH = parseFloat(document.getElementById('treeHeight')?.value || 0);
    let wasBlocked = false;
    
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      
      const dist = profileData[i].dist;
      const terrainElev = profileData[i].elev + treeH;
      const terrainY = toY(terrainElev);
      
      // Calculate line Y position at this distance
      const px = toX(dist);
      const t = (px - x1) / (x2 - x1);
      const lineY = y1 + (y2 - y1) * t;
      
      const isBlocked = terrainY < lineY; // terrain Y is smaller (higher on canvas) means it blocks
      
      // Only mark entry and exit points
      if (isBlocked && !wasBlocked) {
        // Entering obstruction - store X position and Y position on the line
        obstructions.push({ x: px, y: lineY, type: 'entry' });
      } else if (!isBlocked && wasBlocked) {
        // Exiting obstruction - mark previous point
        if (i > 1 && profileData[i-1].elev !== null) {
          const prevDist = profileData[i-1].dist;
          const prevPx = toX(prevDist);
          const prevT = (prevPx - x1) / (x2 - x1);
          const prevLineY = y1 + (y2 - y1) * prevT;
          obstructions.push({ x: prevPx, y: prevLineY, type: 'exit' });
        }
      }
      
      wasBlocked = isBlocked;
    }
    
    return obstructions;
  }
  
  // Draw obstruction markers for manual towers
  if (showUserTowers && firstValid && lastValid) {
    const startTowerH = parseFloat(document.getElementById('startTowerHeight')?.value || 0);
    const endTowerH = parseFloat(document.getElementById('endTowerHeight')?.value || 0);
    
    const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startTowerH);
    const x2 = toX(lastValid.dist), y2 = toY(lastValid.elev + endTowerH);
    
    const obstructions = findLineObstructions(x1, y1, x2, y2);
    
    if (obstructions.length > 0) {
      ctx.save();
      ctx.strokeStyle = '#ffb340';
      ctx.lineWidth = 2;
      
      obstructions.forEach(obs => {
        ctx.beginPath();
        ctx.moveTo(obs.x-5, obs.y-5); ctx.lineTo(obs.x+5, obs.y+5);
        ctx.moveTo(obs.x+5, obs.y-5); ctx.lineTo(obs.x-5, obs.y+5);
        ctx.stroke();
      });
      
      ctx.restore();
    }
  }
  
  // Draw obstruction markers for minimum towers
  if (showMinTowers && firstValid && lastValid) {
    const treeH = parseFloat(document.getElementById('treeHeight')?.value || 0);
    const totalDist = lastValid.dist - firstValid.dist;
    
    // Calculate minimum tower heights (same logic as before)
    let startHeightNeeded = 0;
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeH;
      const progress = (iDist - firstValid.dist) / totalDist;
      if (progress < 1) {
        const requiredH = (iElev - firstValid.elev - lastValid.elev * progress) / (1 - progress);
        startHeightNeeded = Math.max(startHeightNeeded, requiredH);
      }
    }
    startHeightNeeded = Math.max(0, startHeightNeeded);
    
    let endHeightNeeded = 0;
    for (let i = 1; i < profileData.length - 1; i++) {
      if (profileData[i].elev === null) continue;
      const iDist = profileData[i].dist;
      const iElev = profileData[i].elev + treeH;
      const reverseProgress = (lastValid.dist - iDist) / totalDist;
      if (reverseProgress < 1) {
        const requiredH = (iElev - lastValid.elev - firstValid.elev * reverseProgress) / (1 - reverseProgress);
        endHeightNeeded = Math.max(endHeightNeeded, requiredH);
      }
    }
    endHeightNeeded = Math.max(0, endHeightNeeded);
    
    // Draw obstructions for start tower line
    if (startHeightNeeded > 0) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + startHeightNeeded);
      const x2 = toX(lastValid.dist), y2 = toY(lastValid.elev);
      const obstructions = findLineObstructions(x1, y1, x2, y2);
      
      if (obstructions.length > 0) {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,179,64,1)';
        ctx.lineWidth = 2;
        
        obstructions.forEach(obs => {
          ctx.beginPath();
          ctx.moveTo(obs.x-5, obs.y-5); ctx.lineTo(obs.x+5, obs.y+5);
          ctx.moveTo(obs.x+5, obs.y-5); ctx.lineTo(obs.x-5, obs.y+5);
          ctx.stroke();
        });
        
        ctx.restore();
      }
    }
    
    // Draw obstructions for end tower line
    if (endHeightNeeded > 0) {
      const x1 = toX(lastValid.dist), y1 = toY(lastValid.elev + endHeightNeeded);
      const x2 = toX(firstValid.dist), y2 = toY(firstValid.elev);
      const obstructions = findLineObstructions(x1, y1, x2, y2);
      
      if (obstructions.length > 0) {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,140,100,1)';
        ctx.lineWidth = 2;
        
        obstructions.forEach(obs => {
          ctx.beginPath();
          ctx.moveTo(obs.x-5, obs.y-5); ctx.lineTo(obs.x+5, obs.y+5);
          ctx.moveTo(obs.x+5, obs.y-5); ctx.lineTo(obs.x-5, obs.y+5);
          ctx.stroke();
        });
        
        ctx.restore();
      }
    }
  }
  
  // Draw obstruction markers for optimal towers
  if (showOptimalTowers && firstValid && lastValid) {
    const optimal = calculateOptimalTowerHeights(profileData, treeHeight);
    
    if (optimal && optimal.totalHeight < Infinity) {
      const x1 = toX(firstValid.dist), y1 = toY(firstValid.elev + optimal.startHeight);
      const x2 = toX(lastValid.dist), y2 = toY(lastValid.elev + optimal.endHeight);
      const obstructions = findLineObstructions(x1, y1, x2, y2);
      
      if (obstructions.length > 0) {
        ctx.save();
        ctx.strokeStyle = '#4effa0';
        ctx.lineWidth = 2;
        
        obstructions.forEach(obs => {
          ctx.beginPath();
          ctx.moveTo(obs.x-5, obs.y-5); ctx.lineTo(obs.x+5, obs.y+5);
          ctx.moveTo(obs.x+5, obs.y-5); ctx.lineTo(obs.x-5, obs.y+5);
          ctx.stroke();
        });
        
        ctx.restore();
      }
    }
  }

  /* ‚îÄ‚îÄ‚îÄ HOVER CURSOR on radial line ‚îÄ‚îÄ‚îÄ */
  if (hoverDistance !== null && firstValid && lastValid) {
    const maxDist = lastValid.dist;
    if (hoverDistance >= 0 && hoverDistance <= maxDist) {
      const hx = toX(hoverDistance);
      
      // Find closest profile point to interpolate elevation
      let hoverElev = null;
      for (let i = 0; i < profileData.length - 1; i++) {
        if (profileData[i].elev !== null && profileData[i+1].elev !== null) {
          if (hoverDistance >= profileData[i].dist && hoverDistance <= profileData[i+1].dist) {
            const t = (hoverDistance - profileData[i].dist) / (profileData[i+1].dist - profileData[i].dist);
            hoverElev = profileData[i].elev + t * (profileData[i+1].elev - profileData[i].elev);
            break;
          }
        }
      }
      
      if (hoverElev !== null) {
        const hy = toY(hoverElev);
        
        // Draw vertical line
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 180, 64, 0.8)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(hx, pad.top);
        ctx.lineTo(hx, actualH - pad.bottom);
        ctx.stroke();
        
        // Draw circle at intersection with terrain
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.arc(hx, hy, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#ffb440';
        ctx.fill();
        ctx.strokeStyle = '#0a0c0f';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  /* start / end dots */
  if (firstValid) {
    ctx.beginPath();
    ctx.arc(toX(firstValid.dist), toY(firstValid.elev), 5, 0, Math.PI*2);
    ctx.fillStyle = '#4effa0'; ctx.fill();
    ctx.strokeStyle = '#0a0c0f'; ctx.lineWidth = 2.5; ctx.stroke();
  }
  if (lastValid) {
    ctx.beginPath();
    ctx.arc(toX(lastValid.dist), toY(lastValid.elev), 5, 0, Math.PI*2);
    ctx.fillStyle = '#4e9fff'; ctx.fill();
    ctx.strokeStyle = '#0a0c0f'; ctx.lineWidth = 2.5; ctx.stroke();
  }

  canvas._drawParams = { pad, pw, ph, toX, toY, minElev, maxElev, maxDist, elevRange, padElev };
}

function var_danger() { return '#ff5c5c'; }

// Auto-update profile when options change
['showLOS', 'showUserTowers', 'showMinTowers', 'showOptimalTowers'].forEach(id => {
  document.getElementById(id)?.addEventListener('change', () => {
    // Use blue line profile if available and not hovering
    const activeTab = getActiveTab();
    if (activeTab === 'ab' && !hoverLocation && blueLineProfileData.length > 0) {
      profileData = blueLineProfileData;
      cachedLOS = blueLineLOS;
    }
    if (profileData.length > 0) drawProfile(cachedLOS);
  });
});

['startTowerHeight', 'endTowerHeight', 'treeHeight'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      // Use blue line profile if available and not hovering
      const activeTab = getActiveTab();
      if (activeTab === 'ab' && !hoverLocation && blueLineProfileData.length > 0) {
        profileData = blueLineProfileData;
        cachedLOS = blueLineLOS;
      }
      if (profileData.length > 0) drawProfile(cachedLOS);
    });
  }
});

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   STATUS MESSAGE
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
function setStatus(msg, isError) {
  statusMsg.textContent = msg;
  statusMsg.classList.toggle('error', isError);
  statusMsg.style.display = msg ? 'block' : 'none';
}

/* ‚îÄ‚îÄ‚îÄ PROFILE TOOLTIP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
canvas.addEventListener('mousemove', e => {
  if (!canvas._drawParams || !profileData.length) return;
  const rect = canvas.getBoundingClientRect();
  const mx   = e.clientX - rect.left;
  const { pad, maxDist } = canvas._drawParams;
  const pw = rect.width - pad.left - pad.right;
  const d  = ((mx - pad.left) / pw) * maxDist;
  if (d < 0 || d > maxDist) { tooltip.classList.remove('visible'); return; }

  let closest = null, bestDiff = Infinity;
  profileData.forEach(p => { if (p.elev===null) return; const diff=Math.abs(p.dist-d); if(diff<bestDiff){bestDiff=diff;closest=p;} });
  if (!closest) { tooltip.classList.remove('visible'); return; }

  document.getElementById('ttElev').textContent = Math.round(closest.elev)+' m';
  document.getElementById('ttDist').textContent = ' ¬∑ '+closest.dist.toFixed(2)+' km';
  tooltip.style.left = (mx+14)+'px';
  tooltip.style.top  = (e.clientY - rect.top - 20)+'px';
  tooltip.classList.add('visible');
});
canvas.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   GENERATE RADIAL LOS
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
document.getElementById('btnGenerateRadial')?.addEventListener('click', generateRadial);

function generateRadial() {
  const lat     = parseFloat(document.getElementById('obsLat').value);
  const lng     = parseFloat(document.getElementById('obsLng').value);
  const radius  = parseFloat(document.getElementById('radRadius').value);
  const angRes  = parseFloat(document.getElementById('radAngRes').value);
  // Use the same sample count as A‚ÜíB profile for consistency
  const samples = parseInt(document.getElementById('sampleCount').value);
  const obsH    = parseFloat(document.getElementById('obsHeight').value) || 0;
  const remoteH = 0; // Remote tower always 0 for radial LOS
  const treeH   = parseFloat(document.getElementById('treeHeight')?.value || 5);

  if (isNaN(lat)||isNaN(lng)||isNaN(radius)) { 
    setStatus('Observer location and radius are required.', true); 
    return; 
  }
  if (radius <= 0) { 
    setStatus('Radius must be > 0.', true); 
    return; 
  }

  observerLocation = { lat, lng };

  const obsElev = getElevation(lat, lng);
  if (obsElev === null) { 
    setStatus('No elevation data at observer point ‚Äî check tiles.', true); 
    return; 
  }

  const totalObsElev = obsElev + obsH;
  radialData = [];

  const numRays = Math.round(360 / angRes);
  let visCount = 0, blkCount = 0;

  setStatus('Computing‚Ä¶', false);

  setTimeout(() => {
    // Simple visibility check (no heatmap mode)
    if (false) {
      const maxTowerH = parseFloat(document.getElementById('radMaxTowerHeight')?.value || 50);
      
      for (let i = 0; i < numRays; i++) {
        const bearing = (i * angRes) % 360;
        const target  = destPoint(lat, lng, bearing, radius);
        const targetElev = getElevation(target.lat, target.lng) || 0;
        
        let minH = 0, maxH = maxTowerH;
        let requiredHeight = maxTowerH;
        
        for (let iter = 0; iter < 20; iter++) {
          const testH = (minH + maxH) / 2;
          const result = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, treeH, targetElev + testH);
          
          if (result.visible) {
            requiredHeight = testH;
            maxH = testH;
          } else {
            minH = testH;
          }
        }
        
        // Check actual visibility with the required height to get correct visibleDist
        const finalResult = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, treeH, targetElev + requiredHeight);
        
        // Calculate first hill obstruction (without trees) for visualization
        const hillResult = checkLOS(lat, lng, totalObsElev, target.lat, target.lng, samples, 0, targetElev + requiredHeight);
        
        radialData.push({
          bearing,
          visible: requiredHeight < maxTowerH,
          visibleDist: finalResult.visible ? radius : finalResult.visibleDist,
          blockElev: finalResult.blockElev,
          blockDist: finalResult.blockDist,
          requiredTowerHeight: requiredHeight,
          radius: radius,
          hillBlockDist: hillResult.visibleDist  // Distance to first hill obstruction (no trees)
        });
        
        if (requiredHeight < maxTowerH) visCount++; else blkCount++;
      }
    } else {
      // For efficiency, use fewer samples for intermediate LOS checks
      const losCheckSamples = 50; // Reduced from 100 for better performance
      
      for (let i = 0; i < numRays; i++) {
        const bearing = (i * angRes) % 360;
        const target  = destPoint(lat, lng, bearing, radius);
        const targetElev = getElevation(target.lat, target.lng);
        if (targetElev === null) continue;
        
        // Generate profile data for this ray
        const rayProfileData = [];
        for (let j = 0; j <= samples; j++) {
          const t = j / samples;
          const pt = interpolateLine(lat, lng, target.lat, target.lng, t);
          const elev = getElevation(pt.lat, pt.lng);
          const d = radius * t;
          rayProfileData.push({ dist: d, elev: elev !== null ? elev : null, lat: pt.lat, lng: pt.lng });
        }
        
        // For each point along the profile, check if a remote tower (0m height) at that point has LOS to observer
        const losSegments = [];
        let currentSegmentStart = 0;
        let currentSegmentHasLOS = null;
        
        // Sample points along the ray - use more frequent sampling for better accuracy
        const checkInterval = Math.max(1, Math.floor(samples / 100)); // Check ~100 points
        
        for (let j = 0; j < rayProfileData.length; j += checkInterval) {
          const point = rayProfileData[j];
          if (point.elev === null) continue;
          
          const pointDist = point.dist;
          
          // Points very close to observer always have LOS
          if (pointDist < 0.01) {
            if (currentSegmentHasLOS === null) {
              currentSegmentHasLOS = true;
            }
            continue;
          }
          
          // Check LOS from observer tower to this remote point with a tower
          // We want to know: can the observer tower see a tower at this remote location?
          // Use the remote tower height from the settings (same as used in A->B profile)
          const remoteH = parseFloat(document.getElementById('endTowerHeight')?.value || 0);
          const remoteTowerElev = point.elev + remoteH;
          
          // Check from observer TO remote point with tower, including tree height along the path
          const losResult = checkLOS(lat, lng, totalObsElev, point.lat, point.lng, losCheckSamples, treeH, remoteTowerElev);
          const hasLOS = losResult.visible;
          
          // Initialize or update segment
          if (currentSegmentHasLOS === null) {
            currentSegmentHasLOS = hasLOS;
          } else if (hasLOS !== currentSegmentHasLOS) {
            // Create segment when LOS status changes
            losSegments.push({
              start: currentSegmentStart,
              end: pointDist,
              hasLOS: currentSegmentHasLOS
            });
            currentSegmentStart = pointDist;
            currentSegmentHasLOS = hasLOS;
          }
        }
        
        // Save final segment if we have data
        if (currentSegmentHasLOS !== null) {
          losSegments.push({
            start: currentSegmentStart,
            end: radius,
            hasLOS: currentSegmentHasLOS
          });
        }
        
        // If no segments, assume all visible (flat terrain case)
        if (losSegments.length === 0) {
          losSegments.push({
            start: 0,
            end: radius,
            hasLOS: true
          });
        }
        
        // Count as visible if any segment has LOS
        const anyVisible = losSegments.some(seg => seg.hasLOS);

        radialData.push({
          bearing,
          visible: anyVisible,
          profileData: rayProfileData,
          losSegments: losSegments,
          radius: radius
        });
        
        if (anyVisible) visCount++; else blkCount++;
      }
    }

    setStatus(`Radial scan complete ¬∑ ${numRays} rays ¬∑ ${visCount} visible ¬∑ ${blkCount} blocked`, false);
    
    // First draw to get the map parameters
    drawTerrainMap();
    
    // Zoom into radial LOS area - calculate actual extent of radial lines
    if (observerLocation && radialData && radialData.length > 0 && mapCanvas._mapParams) {
      // Find the actual extent of the radial lines
      let radMinLat = observerLocation.lat, radMaxLat = observerLocation.lat;
      let radMinLng = observerLocation.lng, radMaxLng = observerLocation.lng;
      
      radialData.forEach(ray => {
        const endPoint = destPoint(observerLocation.lat, observerLocation.lng, ray.bearing, ray.radius);
        radMinLat = Math.min(radMinLat, endPoint.lat);
        radMaxLat = Math.max(radMaxLat, endPoint.lat);
        radMinLng = Math.min(radMinLng, endPoint.lng);
        radMaxLng = Math.max(radMaxLng, endPoint.lng);
      });
      
      // Get map parameters from the drawn canvas
      const { minLat, maxLat, minLng, maxLng, latRange, lngRange, W, H } = mapCanvas._mapParams;
      
      // Add padding to radial extent (10% on each side)
      const radLatRange = (radMaxLat - radMinLat) * 1.2;
      const radLngRange = (radMaxLng - radMinLng) * 1.2;
      
      // Calculate zoom to fit radial area
      const zoomLat = latRange / radLatRange;
      const zoomLng = lngRange / radLngRange;
      mapZoom = Math.min(zoomLat, zoomLng, 10); // Cap at 10x
      
      // Calculate offset to center on observer
      // Observer position in canvas data coordinates (0,0 to W,H):
      const obsPosX = W * (observerLocation.lng - minLng) / lngRange;
      const obsPosY = H * (1 - (observerLocation.lat - minLat) / latRange);
      
      // Transform: translate(W/2, H/2) -> scale(zoom) -> translate(-W/2 + offsetX, -H/2 + offsetY)
      // For observer at (obsPosX, obsPosY) to be at screen center (W/2, H/2):
      // W/2 + (obsPosX - W/2 + offsetX) * zoom = W/2
      // (obsPosX - W/2 + offsetX) * zoom = 0
      // offsetX = W/2 - obsPosX
      mapOffsetX = W/2 - obsPosX;
      mapOffsetY = H/2 - obsPosY;
      
      document.getElementById('zoomIndicator').textContent = mapZoom.toFixed(1) + 'x';
      drawTerrainMap();
    }
  }, 30);
}

}); // End DOMContentLoaded
</script>
</body>
</html>
